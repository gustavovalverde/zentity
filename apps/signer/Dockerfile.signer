# syntax=docker/dockerfile:1
# Signer Dockerfile for Railway deployment
# Builds only the signer binary and runtime image

# Global build arguments
ARG SOURCE_DATE_EPOCH=0
ARG GIT_SHA=unknown
ARG BUILD_TIME=unknown

# User configuration (APP_ prefix avoids system variable collision)
ARG APP_UID=10001
ARG APP_GID=${APP_UID}
ARG APP_USER=signer
ARG APP_HOME=/app

# --- Stage 1: Builder ---
FROM rust:1.91-trixie@sha256:867f1d1162913c401378a8504fb17fe2032c760dc316448766f150a130204aad AS builder
SHELL ["/bin/bash", "-o", "pipefail", "-c"]

ARG APP_HOME
WORKDIR ${APP_HOME}

ARG SOURCE_DATE_EPOCH
ARG GIT_SHA
ARG BUILD_TIME
ENV SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/* /tmp/*

# Copy manifests first for dependency caching
COPY --link Cargo.toml Cargo.lock ./

# Create dummy src for dependency caching
RUN mkdir -p src/bin && \
    echo "fn main() {}" > src/bin/coordinator.rs && \
    echo "fn main() {}" > src/bin/signer.rs && \
    echo "pub fn dummy() {}" > src/lib.rs

# Build dependencies only (this layer is cached)
# --locked ensures reproducible builds using Cargo.lock
RUN cargo build --locked --release && \
    rm -rf src

# Copy actual source
COPY --link src ./src
COPY --link build.rs ./
RUN touch src/lib.rs src/bin/coordinator.rs src/bin/signer.rs

# Build with build info (option_env! reads these at compile time)
ENV GIT_SHA=${GIT_SHA}
ENV BUILD_TIME=${BUILD_TIME}
RUN cargo build --locked --release --bin signer && \
    cp target/release/signer ./signer

# --- Stage 2: Signer Runtime ---
FROM debian:bookworm-slim@sha256:e899040a73d36e2b36fa33216943539d9957cba8172b858097c2cabcdb20a3e2

ARG APP_UID
ARG APP_GID
ARG APP_USER
ARG APP_HOME

WORKDIR ${APP_HOME}

RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    gosu \
    && rm -rf /var/lib/apt/lists/* /tmp/*

COPY --link --from=builder ${APP_HOME}/signer ${APP_HOME}/signer

# Create non-root user (high UID/GID avoids host user namespace conflicts)
RUN groupadd --gid ${APP_GID} ${APP_USER} && \
    useradd --uid ${APP_UID} --gid ${APP_USER} --shell /sbin/nologin ${APP_USER} && \
    mkdir -p /var/lib/zentity/signer ${APP_HOME}/.data && \
    touch /var/lib/zentity/signer/.keep && \
    chown -R ${APP_UID}:${APP_GID} ${APP_HOME} /var/lib/zentity

COPY --link start-signer.sh ./start.sh
RUN chmod +x start.sh

ENV RUST_LOG=info
ENV SIGNER_ROLE=signer

ARG PORT=5101
ENV SIGNER_PORT=${PORT}

EXPOSE ${PORT}

# Note: Container starts as root to fix volume permissions, then drops to ${APP_USER} via gosu

# Health check (use 127.0.0.1 explicitly to avoid DNS resolution in minimal containers)
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://127.0.0.1:${SIGNER_PORT}/health || exit 1

CMD ["./start.sh"]
