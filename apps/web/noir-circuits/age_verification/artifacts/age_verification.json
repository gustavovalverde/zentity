{
  "noir_version": "1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95",
  "hash": "5967685987847757207",
  "abi": {
    "parameters": [
      {
        "name": "birth_year",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "current_year",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "min_age",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      { "name": "nonce", "type": { "kind": "field" }, "visibility": "public" }
    ],
    "return_type": {
      "abi_type": { "kind": "boolean" },
      "visibility": "public"
    },
    "error_types": {
      "1998584279744703196": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "15783691831417874490": {
        "error_kind": "string",
        "string": "Birth year cannot be in the future"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/7VYvY7TQBCetZ2QH5NcjM2FuHGBEEgUIDoaCoREheigQSfEWcgFASJzEuU9AvAClDwBAomHoOeEdAUSokpDHc53O9zcZm3vrJ1pJtnZ2fnm290vjgWcmCf9i6fZPD7y15VxB9ZNSJ+AkQnGXK0l9VOOa1CsHem7GHWlLwI/lbGupohrXvw/AJx7Y/fB4vDmx2tfHt77vL//+MnVW7/vv/366t3dw7/vl0dzO2ZzPyxLsJmYo+Cvq8PBdA7OYqqaT3ku8gruPfldQAmRlrhNsKD1mhTsaQiuy+2B+WHqM/DY9tAH/U2uyu0D7zBylaIrcTmMvPFqteLwNQDzHujhxbw2lVEAj0/Vkvopa8o4lN7HKDZYBFRl9KG5MtIm65RxCOYb6YMdeVxl5GA6D3bKWOS1rYxDJha0UZOCI+Ar4wjMD9OYgce2hzHwlXEMm1VGX+LiKiOHry0w74EeXsxrUxkd4PGpWlI/ZU0ZJ9IHGMUGi4CqjAE0V0baZJ0yTsB8IwOwI4+rjBxMF8BOGYu8tpVxwsSCFjYpGAJfGUMwP0wRA49tDxHwlTGCzSpjIHFxlZHD10Uw74EeXsyrUkbupWP8IRSGj0iiLJCAWS7ta1v6KUaRjKlmQU8ptKnm69R1m4FhCnakci8cxcSp5TLrbIDT43Uvgd2lwbw2Lw3jF1EY4m710sykjzGKZMzg9GcPx2JofpFsCam7SDMGhhjsiOYofZHvMTDNgHdo0Vwy5sDpXhXmwdnNviz97U+/Hk2Xgx90zSvSH/w5uPM9/RbjOObjQdnNFumzPNtLd7J5nj5PFzuv37zMs3Se44st9AOCzDXvzsH8oV3+yZtXxQbk81AtKL2nyRMl3x3FV82tenD0NTFcM5Ce4sU+tqSnu7GXLvK+HEcOI1KPwaHA/NAuX7sHEfmM62IdymMCPMMb0NHE1L11lbroBb++KMOh22/cy5CMIR//AOj22EMSGQAA",
  "debug_symbols": "nZPdioMwEEbfJdde5NfEvsqylNTGEghRUi0s0nffcUZte7GweDNHM/kOOCYzu4bLdDvH3PV3dvqa2aXElOLtnPrWj7HPsDo/K7a9nscSAiyxtz6kBl9CHtkpTylV7OHThJvug8/I0Rfo8oqFfAWCsIspLE/P6pXmf0cbp9aw4PyVN+K/AsFlsxu0O2Swcje4+ohBcbsZlBZHDNqKzWC4PmIwxuwGqz4M3/Dm21g+fj7jsLNiAqvEqrBqrAZrjdVidVgbSq1hSMPshCQogiYYQk2wBEdoEJITyCLBAodBKoImGEJNsARHaBCKEwSBLAosGqAJhlATwAKzUo4Alhq+mhMEASzLSXj4Ev0lhfW2dFNu3y7P+DNsne16DaVvw3UqYZk19mD6vw==",
  "file_map": {
    "51": {
      "source": "// Age Verification Circuit\n// Proves that a person is at least `min_age` years old without revealing their birth year\n//\n// Public inputs:\n//   - current_year: The current year (e.g., 2025)\n//   - min_age: The minimum age threshold (e.g., 18, 21, 25)\n//   - nonce: Challenge nonce for replay resistance\n//\n// Private inputs:\n//   - birth_year: The person's birth year (kept private)\n//\n// Output:\n//   - Returns true if age >= min_age\n\nfn main(\n    birth_year: Field,       // Private: actual birth year\n    current_year: pub Field, // Public: current year for verification\n    min_age: pub Field,      // Public: minimum age threshold\n    nonce: pub Field         // Public: challenge nonce (replay resistance)\n) -> pub bool {\n    // Nonce is included as public input for replay resistance\n    // It doesn't affect the age calculation, but binds the proof to a specific challenge\n    let _ = nonce;\n    // Convert to u32 for safe comparison and arithmetic\n    let birth_year_u32 = birth_year as u32;\n    let current_year_u32 = current_year as u32;\n    let min_age_u32 = min_age as u32;\n\n    // SECURITY: Prevent wrap-around attack\n    // Without this check, a birth_year > current_year would cause Field underflow,\n    // resulting in a very large positive \"age\" that passes any min_age check.\n    assert(birth_year_u32 <= current_year_u32, \"Birth year cannot be in the future\");\n\n    // Calculate age safely in u32 (no overflow possible after assertion)\n    let age = current_year_u32 - birth_year_u32;\n\n    // Verify age meets minimum requirement\n    age >= min_age_u32\n}\n\n#[test]\nfn test_age_verification_adult() {\n    // Person born in 1990, current year 2025, minimum age 18\n    // Age = 2025 - 1990 = 35, which is >= 18\n    let result = main(1990, 2025, 18, 12345); // nonce can be any value\n    assert(result == true);\n}\n\n#[test]\nfn test_age_verification_exactly_18() {\n    // Person born in 2007, current year 2025, minimum age 18\n    // Age = 2025 - 2007 = 18, which is >= 18\n    let result = main(2007, 2025, 18, 99999);\n    assert(result == true);\n}\n\n#[test]\nfn test_age_verification_under_21() {\n    // Person born in 2007, current year 2025, minimum age 21\n    // Age = 2025 - 2007 = 18, which is < 21\n    let result = main(2007, 2025, 21, 11111);\n    assert(result == false);\n}\n\n#[test]\nfn test_age_verification_minor() {\n    // Person born in 2010, current year 2025, minimum age 18\n    // Age = 2025 - 2010 = 15, which is < 18\n    let result = main(2010, 2025, 18, 22222);\n    assert(result == false);\n}\n\n#[test]\nfn test_same_year_birth() {\n    // Born this year - age 0\n    let result = main(2025, 2025, 0, 33333);\n    assert(result == true);\n\n    let result2 = main(2025, 2025, 1, 44444);\n    assert(result2 == false);\n}\n\n#[test(should_fail_with = \"Birth year cannot be in the future\")]\nfn test_future_birth_year_fails() {\n    // Person \"born\" in the future - should fail assertion\n    let _ = main(2030, 2025, 18, 55555);\n}\n",
      "path": "/Users/gustavovalverde/dev/personal/zentity/apps/web/noir-circuits/age_verification/src/main.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
