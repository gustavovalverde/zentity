diff --git a/dist/client.d.mts b/dist/client.d.mts
index 6954ab42ad237fd6701d9f63ce549f3dd01f7130..5fb5ac26ce671fd9ac83dc93be10d3bec98c2d07 100644
--- a/dist/client.d.mts
+++ b/dist/client.d.mts
@@ -1,4 +1,5 @@
-import { i as WebAuthnChallengeValue, n as Passkey, r as PasskeyOptions, t as passkey } from "./index-C3Ju4ySN.mjs";
+import { a as PasskeyOptions, c as WebAuthnChallengeValue, i as PasskeyExtensionsResolver, n as Passkey, o as PasskeyRegistrationOptions, r as PasskeyAuthenticationOptions, s as PasskeyRegistrationUser, t as passkey } from "./index-DZOpTyeu.mjs";
+import { AuthenticationExtensionsClientInputs, AuthenticationExtensionsClientOutputs, AuthenticationResponseJSON, RegistrationResponseJSON } from "@simplewebauthn/server";
 import * as better_auth_client0 from "better-auth/client";
 import * as nanostores0 from "nanostores";
 import { atom } from "nanostores";
@@ -37,6 +38,18 @@ declare const PASSKEY_ERROR_CODES: {
     code: "FAILED_TO_UPDATE_PASSKEY";
     message: "Failed to update passkey";
   };
+  readonly SESSION_REQUIRED: {
+    code: "SESSION_REQUIRED";
+    message: "Passkey registration requires an authenticated session";
+  };
+  readonly RESOLVE_USER_REQUIRED: {
+    code: "RESOLVE_USER_REQUIRED";
+    message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+  };
+  readonly RESOLVED_USER_INVALID: {
+    code: "RESOLVED_USER_INVALID";
+    message: "Resolved user is invalid";
+  };
 };
 //#endregion
 //#region src/client.d.ts
@@ -53,6 +66,8 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
      */
     passkey: (opts?: {
       autoFill?: boolean;
+      extensions?: AuthenticationExtensionsClientInputs;
+      returnWebAuthnResponse?: boolean;
       fetchOptions?: ClientFetchOption;
     } | undefined, options?: ClientFetchOption | undefined) => Promise<{
       data: null;
@@ -67,6 +82,27 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
         user: User;
       };
       error: null;
+    } | {
+      webauthn: {
+        response: AuthenticationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: null;
+      error: {
+        message?: string | undefined;
+        status: number;
+        statusText: string;
+      };
+    } | {
+      webauthn: {
+        response: AuthenticationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: {
+        session: Session;
+        user: User;
+      };
+      error: null;
     } | {
       data: null;
       error: {
@@ -93,12 +129,24 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
        * platform and cross-platform allowed, with platform preferred.
        */
       authenticatorAttachment?: "platform" | "cross-platform";
+      /**
+       * Optional context for passkey-first registration flows.
+       */
+      context?: string | null;
+      /**
+       * Optional WebAuthn extensions to include during registration.
+       */
+      extensions?: AuthenticationExtensionsClientInputs;
       /**
        * Try to silently create a passkey with the password manager that the user just signed
        * in with.
        * @default false
        */
       useAutoRegister?: boolean;
+      /**
+       * Return WebAuthn response and extension results.
+       */
+      returnWebAuthnResponse?: boolean;
     } | undefined, fetchOpts?: ClientFetchOption | undefined) => Promise<{
       data: null;
       error: {
@@ -109,6 +157,13 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
     } | {
       data: Passkey;
       error: null;
+    } | {
+      webauthn: {
+        response: RegistrationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: Passkey;
+      error: null;
     } | {
       data: null;
       error: {
@@ -136,6 +191,8 @@ declare const passkeyClient: () => {
        */
       passkey: (opts?: {
         autoFill?: boolean;
+        extensions?: AuthenticationExtensionsClientInputs;
+        returnWebAuthnResponse?: boolean;
         fetchOptions?: ClientFetchOption;
       } | undefined, options?: ClientFetchOption | undefined) => Promise<{
         data: null;
@@ -150,6 +207,27 @@ declare const passkeyClient: () => {
           user: User;
         };
         error: null;
+      } | {
+        webauthn: {
+          response: AuthenticationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: null;
+        error: {
+          message?: string | undefined;
+          status: number;
+          statusText: string;
+        };
+      } | {
+        webauthn: {
+          response: AuthenticationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: {
+          session: Session;
+          user: User;
+        };
+        error: null;
       } | {
         data: null;
         error: {
@@ -176,12 +254,24 @@ declare const passkeyClient: () => {
          * platform and cross-platform allowed, with platform preferred.
          */
         authenticatorAttachment?: "platform" | "cross-platform";
+        /**
+         * Optional context for passkey-first registration flows.
+         */
+        context?: string | null;
+        /**
+         * Optional WebAuthn extensions to include during registration.
+         */
+        extensions?: AuthenticationExtensionsClientInputs;
         /**
          * Try to silently create a passkey with the password manager that the user just signed
          * in with.
          * @default false
          */
         useAutoRegister?: boolean;
+        /**
+         * Return WebAuthn response and extension results.
+         */
+        returnWebAuthnResponse?: boolean;
       } | undefined, fetchOpts?: ClientFetchOption | undefined) => Promise<{
         data: null;
         error: {
@@ -192,6 +282,13 @@ declare const passkeyClient: () => {
       } | {
         data: Passkey;
         error: null;
+      } | {
+        webauthn: {
+          response: RegistrationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: Passkey;
+        error: null;
       } | {
         data: null;
         error: {
@@ -218,7 +315,7 @@ declare const passkeyClient: () => {
     "/passkey/authenticate": "POST";
   };
   atomListeners: ({
-    matcher(path: string): path is "/passkey/delete-passkey" | "/passkey/update-passkey" | "/passkey/verify-registration" | "/sign-out";
+    matcher(path: string): path is "/passkey/verify-registration" | "/passkey/delete-passkey" | "/passkey/update-passkey" | "/sign-out";
     signal: "$listPasskeys";
   } | {
     matcher: (path: string) => path is "/passkey/verify-authentication";
@@ -253,7 +350,19 @@ declare const passkeyClient: () => {
       code: "FAILED_TO_UPDATE_PASSKEY";
       message: "Failed to update passkey";
     };
+    readonly SESSION_REQUIRED: {
+      code: "SESSION_REQUIRED";
+      message: "Passkey registration requires an authenticated session";
+    };
+    readonly RESOLVE_USER_REQUIRED: {
+      code: "RESOLVE_USER_REQUIRED";
+      message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+    };
+    readonly RESOLVED_USER_INVALID: {
+      code: "RESOLVED_USER_INVALID";
+      message: "Resolved user is invalid";
+    };
   };
 };
 //#endregion
-export { PASSKEY_ERROR_CODES, Passkey, PasskeyOptions, WebAuthnChallengeValue, getPasskeyActions, passkeyClient };
\ No newline at end of file
+export { PASSKEY_ERROR_CODES, Passkey, PasskeyAuthenticationOptions, PasskeyExtensionsResolver, PasskeyOptions, PasskeyRegistrationOptions, PasskeyRegistrationUser, WebAuthnChallengeValue, getPasskeyActions, passkeyClient };
\ No newline at end of file
diff --git a/dist/client.mjs b/dist/client.mjs
index dcbed9d143e2ccbf0d07d590608af448f35fb6af..876617208d66f6b721e798a05b6e53ac3642049b 100644
--- a/dist/client.mjs
+++ b/dist/client.mjs
@@ -1,4 +1,4 @@
-import { t as PASSKEY_ERROR_CODES } from "./error-codes-VuR_tYBt.mjs";
+import { t as PASSKEY_ERROR_CODES } from "./error-codes-Bfg5KAPi.mjs";
 import { WebAuthnError, startAuthentication, startRegistration } from "@simplewebauthn/browser";
 import { useAuthQuery } from "better-auth/client";
 import { atom } from "nanostores";
@@ -12,11 +12,19 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 		});
 		if (!response.data) return response;
 		try {
+			const mergedExtensions = response.data.extensions || opts?.extensions ? {
+				...response.data.extensions || {},
+				...opts?.extensions || {}
+			} : void 0;
+			const res = await startAuthentication({
+				optionsJSON: {
+					...response.data,
+					extensions: mergedExtensions
+				},
+				useBrowserAutofill: opts?.autoFill
+			});
 			const verified = await $fetch("/passkey/verify-authentication", {
-				body: { response: await startAuthentication({
-					optionsJSON: response.data,
-					useBrowserAutofill: opts?.autoFill
-				}) },
+				body: { response: res },
 				...opts?.fetchOptions,
 				...options,
 				method: "POST",
@@ -24,6 +32,13 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			});
 			$listPasskeys.set(Math.random());
 			$store.notify("$sessionSignal");
+			if (opts?.returnWebAuthnResponse) return {
+				...verified,
+				webauthn: {
+					response: res,
+					clientExtensionResults: res.clientExtensionResults
+				}
+			};
 			return verified;
 		} catch {
 			return {
@@ -42,14 +57,22 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			method: "GET",
 			query: {
 				...opts?.authenticatorAttachment && { authenticatorAttachment: opts.authenticatorAttachment },
-				...opts?.name && { name: opts.name }
+				...opts?.name && { name: opts.name },
+				...opts?.context && { context: opts.context }
 			},
 			throw: false
 		});
 		if (!options.data) return options;
 		try {
+			const mergedExtensions = options.data.extensions || opts?.extensions ? {
+				...options.data.extensions || {},
+				...opts?.extensions || {}
+			} : void 0;
 			const res = await startRegistration({
-				optionsJSON: options.data,
+				optionsJSON: {
+					...options.data,
+					extensions: mergedExtensions
+				},
 				useAutoRegister: opts?.useAutoRegister
 			});
 			const verified = await $fetch("/passkey/verify-registration", {
@@ -64,6 +87,13 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			});
 			if (!verified.data) return verified;
 			$listPasskeys.set(Math.random());
+			if (opts?.returnWebAuthnResponse) return {
+				...verified,
+				webauthn: {
+					response: res,
+					clientExtensionResults: res.clientExtensionResults
+				}
+			};
 			return verified;
 		} catch (e) {
 			if (e instanceof WebAuthnError) {
diff --git a/dist/error-codes-VuR_tYBt.mjs b/dist/error-codes-Bfg5KAPi.mjs
similarity index 62%
rename from dist/error-codes-VuR_tYBt.mjs
rename to dist/error-codes-Bfg5KAPi.mjs
index 5a64513418dcb6edfd3d22dde5242c8784e6120d..5d2ef818a84ce75510fa320b68d19384fdcc7de5 100644
--- a/dist/error-codes-VuR_tYBt.mjs
+++ b/dist/error-codes-Bfg5KAPi.mjs
@@ -8,7 +8,10 @@ const PASSKEY_ERROR_CODES = defineErrorCodes({
 	PASSKEY_NOT_FOUND: "Passkey not found",
 	AUTHENTICATION_FAILED: "Authentication failed",
 	UNABLE_TO_CREATE_SESSION: "Unable to create session",
-	FAILED_TO_UPDATE_PASSKEY: "Failed to update passkey"
+	FAILED_TO_UPDATE_PASSKEY: "Failed to update passkey",
+	SESSION_REQUIRED: "Passkey registration requires an authenticated session",
+	RESOLVE_USER_REQUIRED: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false",
+	RESOLVED_USER_INVALID: "Resolved user is invalid"
 });

 //#endregion
diff --git a/dist/index-C3Ju4ySN.d.mts b/dist/index-DZOpTyeu.d.mts
similarity index 86%
rename from dist/index-C3Ju4ySN.d.mts
rename to dist/index-DZOpTyeu.d.mts
index 7ab6fd21f2495aef9a2a3b2e67495d66dc1e633f..512c147fe2ddb478457d44a8357405104979dd5a 100644
--- a/dist/index-C3Ju4ySN.d.mts
+++ b/dist/index-DZOpTyeu.d.mts
@@ -1,6 +1,7 @@
 import * as _simplewebauthn_server0 from "@simplewebauthn/server";
-import { CredentialDeviceType } from "@simplewebauthn/server";
+import { AuthenticationExtensionsClientInputs, AuthenticationResponseJSON, CredentialDeviceType, RegistrationResponseJSON, VerifiedAuthenticationResponse, VerifiedRegistrationResponse } from "@simplewebauthn/server";
 import * as zod0 from "zod";
+import { GenericEndpointContext } from "@better-auth/core";
 import { InferOptionSchema } from "better-auth/types";
 import * as better_call0 from "better-call";
 import * as better_auth0 from "better-auth";
@@ -67,7 +68,66 @@ interface WebAuthnChallengeValue {
   expectedChallenge: string;
   userData: {
     id: string;
+    name?: string | undefined;
+    displayName?: string | undefined;
   };
+  context?: string | null;
+}
+type Awaitable<T> = T | Promise<T>;
+interface PasskeyRegistrationUser {
+  id: string;
+  name: string;
+  displayName?: string | undefined;
+}
+type PasskeyExtensionsResolver = AuthenticationExtensionsClientInputs | ((args: {
+  ctx: GenericEndpointContext;
+}) => Awaitable<AuthenticationExtensionsClientInputs | undefined>);
+interface PasskeyRegistrationOptions {
+  /**
+   * Require an authenticated session for passkey registration.
+   *
+   * @default true
+   */
+  requireSession?: boolean | undefined;
+  /**
+   * Resolve the user when session is not available.
+   * Required when `requireSession` is false and no session exists.
+   */
+  resolveUser?: ((args: {
+    ctx: GenericEndpointContext;
+    context?: string | null | undefined;
+  }) => Awaitable<PasskeyRegistrationUser>) | undefined;
+  /**
+   * Callback after a successful registration verification.
+   * Useful for user linking or auditing.
+   */
+  afterVerification?: ((args: {
+    ctx: GenericEndpointContext;
+    verification: VerifiedRegistrationResponse;
+    user: PasskeyRegistrationUser;
+    clientData: RegistrationResponseJSON;
+    context?: string | null | undefined;
+  }) => Awaitable<{
+    userId?: string;
+  } | void>) | undefined;
+  /**
+   * Optional WebAuthn extensions to include in registration options.
+   */
+  extensions?: PasskeyExtensionsResolver | undefined;
+}
+interface PasskeyAuthenticationOptions {
+  /**
+   * Optional WebAuthn extensions to include in authentication options.
+   */
+  extensions?: PasskeyExtensionsResolver | undefined;
+  /**
+   * Callback after a successful authentication verification.
+   */
+  afterVerification?: ((args: {
+    ctx: GenericEndpointContext;
+    verification: VerifiedAuthenticationResponse;
+    clientData: AuthenticationResponseJSON;
+  }) => Awaitable<void>) | undefined;
 }
 interface PasskeyOptions {
   /**
@@ -112,6 +172,14 @@ interface PasskeyOptions {
    * Schema for the passkey model
    */
   schema?: InferOptionSchema<typeof schema> | undefined;
+  /**
+   * Registration behavior overrides
+   */
+  registration?: PasskeyRegistrationOptions | undefined;
+  /**
+   * Authentication behavior overrides
+   */
+  authentication?: PasskeyAuthenticationOptions | undefined;
 }
 type Passkey = {
   id: string;
@@ -162,6 +230,7 @@ declare const passkey: (options?: PasskeyOptions | undefined) => {
           "cross-platform": "cross-platform";
         }>>;
         name: zod0.ZodOptional<zod0.ZodString>;
+        context: zod0.ZodOptional<zod0.ZodString>;
       }, better_auth0.$strip>>;
       metadata: {
         openapi: {
@@ -180,6 +249,10 @@ declare const passkey: (options?: PasskeyOptions | undefined) => {
                     description: string;
                     required: boolean;
                   };
+                  context: {
+                    description: string;
+                    required: boolean;
+                  };
                 };
               };
               content: {
@@ -714,8 +787,20 @@ declare const passkey: (options?: PasskeyOptions | undefined) => {
       code: "FAILED_TO_UPDATE_PASSKEY";
       message: "Failed to update passkey";
     };
+    readonly SESSION_REQUIRED: {
+      code: "SESSION_REQUIRED";
+      message: "Passkey registration requires an authenticated session";
+    };
+    readonly RESOLVE_USER_REQUIRED: {
+      code: "RESOLVE_USER_REQUIRED";
+      message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+    };
+    readonly RESOLVED_USER_INVALID: {
+      code: "RESOLVED_USER_INVALID";
+      message: "Resolved user is invalid";
+    };
   };
   options: PasskeyOptions | undefined;
 };
 //#endregion
-export { WebAuthnChallengeValue as i, Passkey as n, PasskeyOptions as r, passkey as t };
\ No newline at end of file
+export { PasskeyOptions as a, WebAuthnChallengeValue as c, PasskeyExtensionsResolver as i, Passkey as n, PasskeyRegistrationOptions as o, PasskeyAuthenticationOptions as r, PasskeyRegistrationUser as s, passkey as t };
\ No newline at end of file
diff --git a/dist/index.d.mts b/dist/index.d.mts
index f0b0b99f49a461984a025fba80a6584173952255..8fc685e3f091b72772c69d93cc997811f8b943c9 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,2 +1,2 @@
-import { n as Passkey, r as PasskeyOptions, t as passkey } from "./index-C3Ju4ySN.mjs";
+import { a as PasskeyOptions, n as Passkey, t as passkey } from "./index-DZOpTyeu.mjs";
 export { Passkey, PasskeyOptions, passkey };
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 0c0dba9f9aa88e74d101680739721bd7cbfdea6f..72d874509da9ca956b363ab31cae1b6ca56f5cd3 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,4 +1,4 @@
-import { t as PASSKEY_ERROR_CODES } from "./error-codes-VuR_tYBt.mjs";
+import { t as PASSKEY_ERROR_CODES } from "./error-codes-Bfg5KAPi.mjs";
 import { mergeSchema } from "better-auth/db";
 import { createAuthEndpoint } from "@better-auth/core/api";
 import { APIError } from "@better-auth/core/error";
@@ -16,135 +16,182 @@ function getRpID(options, baseURL) {

 //#endregion
 //#region src/routes.ts
+const resolveExtensions = async (extensions, ctx) => {
+	if (!extensions) return;
+	if (typeof extensions === "function") return await extensions({ ctx });
+	return extensions;
+};
+const resolveRegistrationUser = async (opts, ctx) => {
+	if (opts.registration?.requireSession ?? true) {
+		const session$1 = ctx.context?.session;
+		if (!session$1?.user?.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.SESSION_REQUIRED);
+		const sessionName = session$1.user.email || session$1.user.id;
+		return {
+			id: session$1.user.id,
+			name: sessionName,
+			displayName: sessionName
+		};
+	}
+	const session = await getSessionFromCtx(ctx);
+	if (session?.user?.id) {
+		const sessionName = session.user.email || session.user.id;
+		return {
+			id: session.user.id,
+			name: sessionName,
+			displayName: sessionName
+		};
+	}
+	if (!opts.registration?.resolveUser) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVE_USER_REQUIRED);
+	const resolvedUser = await opts.registration.resolveUser({
+		ctx,
+		context: ctx.query?.context ?? null
+	});
+	if (!resolvedUser?.id || !resolvedUser?.name) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVED_USER_INVALID);
+	return resolvedUser;
+};
 const generatePasskeyQuerySchema = z.object({
 	authenticatorAttachment: z.enum(["platform", "cross-platform"]).optional(),
-	name: z.string().optional()
+	name: z.string().optional(),
+	context: z.string().optional()
 }).optional();
-const generatePasskeyRegistrationOptions = (opts, { maxAgeInSeconds, expirationTime }) => createAuthEndpoint("/passkey/generate-register-options", {
-	method: "GET",
-	use: [freshSessionMiddleware],
-	query: generatePasskeyQuerySchema,
-	metadata: { openapi: {
-		operationId: "generatePasskeyRegistrationOptions",
-		description: "Generate registration options for a new passkey",
-		responses: { 200: {
-			description: "Success",
-			parameters: { query: {
-				authenticatorAttachment: {
-					description: `Type of authenticator to use for registration.
+const generatePasskeyRegistrationOptions = (opts, { maxAgeInSeconds, expirationTime }) => {
+	return createAuthEndpoint("/passkey/generate-register-options", {
+		method: "GET",
+		use: opts.registration?.requireSession ?? true ? [freshSessionMiddleware] : [],
+		query: generatePasskeyQuerySchema,
+		metadata: { openapi: {
+			operationId: "generatePasskeyRegistrationOptions",
+			description: "Generate registration options for a new passkey",
+			responses: { 200: {
+				description: "Success",
+				parameters: { query: {
+					authenticatorAttachment: {
+						description: `Type of authenticator to use for registration.
                           "platform" for device-specific authenticators,
                           "cross-platform" for authenticators that can be used across devices.`,
-					required: false
-				},
-				name: {
-					description: `Optional custom name for the passkey.
-                          This can help identify the passkey when managing multiple credentials.`,
-					required: false
-				}
-			} },
-			content: { "application/json": { schema: {
-				type: "object",
-				properties: {
-					challenge: { type: "string" },
-					rp: {
-						type: "object",
-						properties: {
-							name: { type: "string" },
-							id: { type: "string" }
-						}
+						required: false
 					},
-					user: {
-						type: "object",
-						properties: {
-							id: { type: "string" },
-							name: { type: "string" },
-							displayName: { type: "string" }
-						}
+					name: {
+						description: `Optional custom name for the passkey.
+                          This can help identify the passkey when managing multiple credentials.`,
+						required: false
 					},
-					pubKeyCredParams: {
-						type: "array",
-						items: {
+					context: {
+						description: "Optional context for passkey-first registration flows.",
+						required: false
+					}
+				} },
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						challenge: { type: "string" },
+						rp: {
 							type: "object",
 							properties: {
-								type: { type: "string" },
-								alg: { type: "number" }
+								name: { type: "string" },
+								id: { type: "string" }
 							}
-						}
-					},
-					timeout: { type: "number" },
-					excludeCredentials: {
-						type: "array",
-						items: {
+						},
+						user: {
 							type: "object",
 							properties: {
 								id: { type: "string" },
-								type: { type: "string" },
-								transports: {
-									type: "array",
-									items: { type: "string" }
+								name: { type: "string" },
+								displayName: { type: "string" }
+							}
+						},
+						pubKeyCredParams: {
+							type: "array",
+							items: {
+								type: "object",
+								properties: {
+									type: { type: "string" },
+									alg: { type: "number" }
 								}
 							}
-						}
-					},
-					authenticatorSelection: {
-						type: "object",
-						properties: {
-							authenticatorAttachment: { type: "string" },
-							requireResidentKey: { type: "boolean" },
-							userVerification: { type: "string" }
-						}
-					},
-					attestation: { type: "string" },
-					extensions: { type: "object" }
-				}
-			} } }
+						},
+						timeout: { type: "number" },
+						excludeCredentials: {
+							type: "array",
+							items: {
+								type: "object",
+								properties: {
+									id: { type: "string" },
+									type: { type: "string" },
+									transports: {
+										type: "array",
+										items: { type: "string" }
+									}
+								}
+							}
+						},
+						authenticatorSelection: {
+							type: "object",
+							properties: {
+								authenticatorAttachment: { type: "string" },
+								requireResidentKey: { type: "boolean" },
+								userVerification: { type: "string" }
+							}
+						},
+						attestation: { type: "string" },
+						extensions: { type: "object" }
+					}
+				} } }
+			} }
 		} }
-	} }
-}, async (ctx) => {
-	const { session } = ctx.context;
-	const userPasskeys = await ctx.context.adapter.findMany({
-		model: "passkey",
-		where: [{
-			field: "userId",
-			value: session.user.id
-		}]
-	});
-	const userID = new TextEncoder().encode(generateRandomString(32, "a-z", "0-9"));
-	let options;
-	options = await generateRegistrationOptions({
-		rpName: opts.rpName || ctx.context.appName,
-		rpID: getRpID(opts, ctx.context.options.baseURL),
-		userID,
-		userName: ctx.query?.name || session.user.email || session.user.id,
-		userDisplayName: session.user.email || session.user.id,
-		attestationType: "none",
-		excludeCredentials: userPasskeys.map((passkey$1) => ({
-			id: passkey$1.credentialID,
-			transports: passkey$1.transports?.split(",")
-		})),
-		authenticatorSelection: {
-			residentKey: "preferred",
-			userVerification: "preferred",
-			...opts.authenticatorSelection || {},
-			...ctx.query?.authenticatorAttachment ? { authenticatorAttachment: ctx.query.authenticatorAttachment } : {}
-		}
-	});
-	const verificationToken = generateRandomString(32);
-	const webAuthnCookie = ctx.context.createAuthCookie(opts.advanced.webAuthnChallengeCookie);
-	await ctx.setSignedCookie(webAuthnCookie.name, verificationToken, ctx.context.secret, {
-		...webAuthnCookie.attributes,
-		maxAge: maxAgeInSeconds
-	});
-	await ctx.context.internalAdapter.createVerificationValue({
-		identifier: verificationToken,
-		value: JSON.stringify({
-			expectedChallenge: options.challenge,
-			userData: { id: session.user.id }
-		}),
-		expiresAt: expirationTime
+	}, async (ctx) => {
+		const user = await resolveRegistrationUser(opts, ctx);
+		const userPasskeys = await ctx.context.adapter.findMany({
+			model: "passkey",
+			where: [{
+				field: "userId",
+				value: user.id
+			}]
+		});
+		const registrationExtensions = await resolveExtensions(opts.registration?.extensions, ctx);
+		const userID = new TextEncoder().encode(generateRandomString(32, "a-z", "0-9"));
+		let options;
+		options = await generateRegistrationOptions({
+			rpName: opts.rpName || ctx.context.appName,
+			rpID: getRpID(opts, ctx.context.options.baseURL),
+			userID,
+			userName: ctx.query?.name || user.name || user.id,
+			userDisplayName: user.displayName || user.name || user.id,
+			attestationType: "none",
+			excludeCredentials: userPasskeys.map((passkey$1) => ({
+				id: passkey$1.credentialID,
+				transports: passkey$1.transports?.split(",")
+			})),
+			authenticatorSelection: {
+				residentKey: "preferred",
+				userVerification: "preferred",
+				...opts.authenticatorSelection || {},
+				...ctx.query?.authenticatorAttachment ? { authenticatorAttachment: ctx.query.authenticatorAttachment } : {}
+			},
+			extensions: registrationExtensions
+		});
+		const verificationToken = generateRandomString(32);
+		const webAuthnCookie = ctx.context.createAuthCookie(opts.advanced.webAuthnChallengeCookie);
+		await ctx.setSignedCookie(webAuthnCookie.name, verificationToken, ctx.context.secret, {
+			...webAuthnCookie.attributes,
+			maxAge: maxAgeInSeconds
+		});
+		await ctx.context.internalAdapter.createVerificationValue({
+			identifier: verificationToken,
+			value: JSON.stringify({
+				expectedChallenge: options.challenge,
+				userData: {
+					id: user.id,
+					name: user.name,
+					displayName: user.displayName
+				},
+				context: ctx.query?.context ?? null
+			}),
+			expiresAt: expirationTime
+		});
+		return ctx.json(options, { status: 200 });
 	});
-	return ctx.json(options, { status: 200 });
-});
+};
 const generatePasskeyAuthenticationOptions = (opts, { maxAgeInSeconds, expirationTime }) => createAuthEndpoint("/passkey/generate-authenticate-options", {
 	method: "GET",
 	metadata: { openapi: {
@@ -210,9 +257,11 @@ const generatePasskeyAuthenticationOptions = (opts, { maxAgeInSeconds, expiratio
 			value: session.user.id
 		}]
 	});
+	const authenticationExtensions = await resolveExtensions(opts.authentication?.extensions, ctx);
 	const options = await generateAuthenticationOptions({
 		rpID: getRpID(opts, ctx.context.options.baseURL),
 		userVerification: "preferred",
+		extensions: authenticationExtensions,
 		...userPasskeys.length ? { allowCredentials: userPasskeys.map((passkey$1) => ({
 			id: passkey$1.credentialID,
 			transports: passkey$1.transports?.split(",")
@@ -239,66 +288,91 @@ const verifyPasskeyRegistrationBodySchema = z.object({
 	response: z.any(),
 	name: z.string().meta({ description: "Name of the passkey" }).optional()
 });
-const verifyPasskeyRegistration = (options) => createAuthEndpoint("/passkey/verify-registration", {
-	method: "POST",
-	body: verifyPasskeyRegistrationBodySchema,
-	use: [freshSessionMiddleware],
-	metadata: { openapi: {
-		operationId: "passkeyVerifyRegistration",
-		description: "Verify registration of a new passkey",
-		responses: {
-			200: {
-				description: "Success",
-				content: { "application/json": { schema: { $ref: "#/components/schemas/Passkey" } } }
-			},
-			400: { description: "Bad request" }
+const verifyPasskeyRegistration = (options) => {
+	const requireSession = options.registration?.requireSession ?? true;
+	return createAuthEndpoint("/passkey/verify-registration", {
+		method: "POST",
+		body: verifyPasskeyRegistrationBodySchema,
+		use: requireSession ? [freshSessionMiddleware] : [],
+		metadata: { openapi: {
+			operationId: "passkeyVerifyRegistration",
+			description: "Verify registration of a new passkey",
+			responses: {
+				200: {
+					description: "Success",
+					content: { "application/json": { schema: { $ref: "#/components/schemas/Passkey" } } }
+				},
+				400: { description: "Bad request" }
+			}
+		} }
+	}, async (ctx) => {
+		const origin = options?.origin || ctx.headers?.get("origin") || "";
+		if (!origin) return ctx.json(null, { status: 400 });
+		const resp = ctx.body.response;
+		const webAuthnCookie = ctx.context.createAuthCookie(options.advanced.webAuthnChallengeCookie);
+		const verificationToken = await ctx.getSignedCookie(webAuthnCookie.name, ctx.context.secret);
+		if (!verificationToken) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.CHALLENGE_NOT_FOUND);
+		const data = await ctx.context.internalAdapter.findVerificationValue(verificationToken);
+		if (!data) return ctx.json(null, { status: 400 });
+		const { expectedChallenge, userData, context } = JSON.parse(data.value);
+		const session = requireSession ? ctx.context.session : await getSessionFromCtx(ctx);
+		if (session?.user?.id && userData.id !== session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
+		try {
+			const verification = await verifyRegistrationResponse({
+				response: resp,
+				expectedChallenge,
+				expectedOrigin: origin,
+				expectedRPID: getRpID(options, ctx.context.options.baseURL),
+				requireUserVerification: false
+			});
+			const { verified, registrationInfo } = verification;
+			if (!verified || !registrationInfo) return ctx.json(null, { status: 400 });
+			const { aaguid, credentialDeviceType, credentialBackedUp, credential } = registrationInfo;
+			const resolvedUser = {
+				id: userData.id,
+				name: userData.name || userData.id,
+				displayName: userData.displayName
+			};
+			let targetUserId = resolvedUser.id;
+			if (options.registration?.afterVerification) {
+				const result = await options.registration.afterVerification({
+					ctx,
+					verification,
+					user: resolvedUser,
+					clientData: resp,
+					context
+				});
+				if (result?.userId) {
+					if (typeof result.userId !== "string" || !result.userId) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVED_USER_INVALID);
+					if (session?.user?.id && result.userId !== session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
+					targetUserId = result.userId;
+				}
+			}
+			const pubKey = base64.encode(credential.publicKey);
+			const newPasskey = {
+				name: ctx.body.name,
+				userId: targetUserId,
+				credentialID: credential.id,
+				publicKey: pubKey,
+				counter: credential.counter,
+				deviceType: credentialDeviceType,
+				transports: resp.response.transports.join(","),
+				backedUp: credentialBackedUp,
+				createdAt: /* @__PURE__ */ new Date(),
+				aaguid
+			};
+			const newPasskeyRes = await ctx.context.adapter.create({
+				model: "passkey",
+				data: newPasskey
+			});
+			await ctx.context.internalAdapter.deleteVerificationValue(data.id);
+			return ctx.json(newPasskeyRes, { status: 200 });
+		} catch (e) {
+			ctx.context.logger.error("Failed to verify registration", e);
+			throw APIError.from("INTERNAL_SERVER_ERROR", PASSKEY_ERROR_CODES.FAILED_TO_VERIFY_REGISTRATION);
 		}
-	} }
-}, async (ctx) => {
-	const origin = options?.origin || ctx.headers?.get("origin") || "";
-	if (!origin) return ctx.json(null, { status: 400 });
-	const resp = ctx.body.response;
-	const webAuthnCookie = ctx.context.createAuthCookie(options.advanced.webAuthnChallengeCookie);
-	const verificationToken = await ctx.getSignedCookie(webAuthnCookie.name, ctx.context.secret);
-	if (!verificationToken) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.CHALLENGE_NOT_FOUND);
-	const data = await ctx.context.internalAdapter.findVerificationValue(verificationToken);
-	if (!data) return ctx.json(null, { status: 400 });
-	const { expectedChallenge, userData } = JSON.parse(data.value);
-	if (userData.id !== ctx.context.session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
-	try {
-		const { verified, registrationInfo } = await verifyRegistrationResponse({
-			response: resp,
-			expectedChallenge,
-			expectedOrigin: origin,
-			expectedRPID: getRpID(options, ctx.context.options.baseURL),
-			requireUserVerification: false
-		});
-		if (!verified || !registrationInfo) return ctx.json(null, { status: 400 });
-		const { aaguid, credentialDeviceType, credentialBackedUp, credential } = registrationInfo;
-		const pubKey = base64.encode(credential.publicKey);
-		const newPasskey = {
-			name: ctx.body.name,
-			userId: userData.id,
-			credentialID: credential.id,
-			publicKey: pubKey,
-			counter: credential.counter,
-			deviceType: credentialDeviceType,
-			transports: resp.response.transports.join(","),
-			backedUp: credentialBackedUp,
-			createdAt: /* @__PURE__ */ new Date(),
-			aaguid
-		};
-		const newPasskeyRes = await ctx.context.adapter.create({
-			model: "passkey",
-			data: newPasskey
-		});
-		await ctx.context.internalAdapter.deleteVerificationValue(data.id);
-		return ctx.json(newPasskeyRes, { status: 200 });
-	} catch (e) {
-		ctx.context.logger.error("Failed to verify registration", e);
-		throw APIError.from("INTERNAL_SERVER_ERROR", PASSKEY_ERROR_CODES.FAILED_TO_VERIFY_REGISTRATION);
-	}
-});
+	});
+};
 const verifyPasskeyAuthenticationBodySchema = z.object({ response: z.record(z.any(), z.any()) });
 const verifyPasskeyAuthentication = (options) => createAuthEndpoint("/passkey/verify-authentication", {
 	method: "POST",
@@ -354,6 +428,11 @@ const verifyPasskeyAuthentication = (options) => createAuthEndpoint("/passkey/ve
 		});
 		const { verified } = verification;
 		if (!verified) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.AUTHENTICATION_FAILED);
+		if (options.authentication?.afterVerification) await options.authentication.afterVerification({
+			ctx,
+			verification,
+			clientData: resp
+		});
 		await ctx.context.adapter.update({
 			model: "passkey",
 			where: [{
