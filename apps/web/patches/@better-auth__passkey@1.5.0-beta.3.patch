diff --git a/dist/client.d.mts b/dist/client.d.mts
index d7ba383141afcf7af9ddb95a1545699fdd9e8cdb..0ec6ac02be44a180f91abadd5badf243c4f52120 100644
--- a/dist/client.d.mts
+++ b/dist/client.d.mts
@@ -1,4 +1,5 @@
-import { i as WebAuthnChallengeValue, n as Passkey, r as PasskeyOptions, t as passkey } from "./index-CdIR3B4H.mjs";
+import { a as PasskeyOptions, c as WebAuthnChallengeValue, i as PasskeyExtensionsResolver, n as Passkey, o as PasskeyRegistrationOptions, r as PasskeyAuthenticationOptions, s as PasskeyRegistrationUser, t as passkey } from "./index-D_qGBnrU.mjs";
+import { AuthenticationExtensionsClientInputs, AuthenticationExtensionsClientOutputs, AuthenticationResponseJSON, RegistrationResponseJSON } from "@simplewebauthn/server";
 import * as better_auth_client0 from "better-auth/client";
 import * as nanostores0 from "nanostores";
 import { atom } from "nanostores";
@@ -37,6 +38,18 @@ declare const PASSKEY_ERROR_CODES: {
     code: "FAILED_TO_UPDATE_PASSKEY";
     message: "Failed to update passkey";
   };
+  readonly SESSION_REQUIRED: {
+    code: "SESSION_REQUIRED";
+    message: "Passkey registration requires an authenticated session";
+  };
+  readonly RESOLVE_USER_REQUIRED: {
+    code: "RESOLVE_USER_REQUIRED";
+    message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+  };
+  readonly RESOLVED_USER_INVALID: {
+    code: "RESOLVED_USER_INVALID";
+    message: "Resolved user is invalid";
+  };
 };
 //#endregion
 //#region src/client.d.ts
@@ -53,6 +66,8 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
      */
     passkey: (opts?: {
       autoFill?: boolean;
+      extensions?: AuthenticationExtensionsClientInputs;
+      returnWebAuthnResponse?: boolean;
       fetchOptions?: ClientFetchOption;
     } | undefined, options?: ClientFetchOption | undefined) => Promise<{
       data: null;
@@ -67,6 +82,27 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
         user: User;
       };
       error: null;
+    } | {
+      webauthn: {
+        response: AuthenticationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: null;
+      error: {
+        message?: string | undefined;
+        status: number;
+        statusText: string;
+      };
+    } | {
+      webauthn: {
+        response: AuthenticationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: {
+        session: Session;
+        user: User;
+      };
+      error: null;
     } | {
       data: null;
       error: {
@@ -93,12 +129,24 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
        * platform and cross-platform allowed, with platform preferred.
        */
       authenticatorAttachment?: "platform" | "cross-platform";
+      /**
+       * Optional context for passkey-first registration flows.
+       */
+      context?: string | null;
+      /**
+       * Optional WebAuthn extensions to include during registration.
+       */
+      extensions?: AuthenticationExtensionsClientInputs;
       /**
        * Try to silently create a passkey with the password manager that the user just signed
        * in with.
        * @default false
        */
       useAutoRegister?: boolean;
+      /**
+       * Return WebAuthn response and extension results.
+       */
+      returnWebAuthnResponse?: boolean;
     } | undefined, fetchOpts?: ClientFetchOption | undefined) => Promise<{
       data: null;
       error: {
@@ -109,6 +157,13 @@ declare const getPasskeyActions: ($fetch: BetterFetch, {
     } | {
       data: Passkey;
       error: null;
+    } | {
+      webauthn: {
+        response: RegistrationResponseJSON;
+        clientExtensionResults: AuthenticationExtensionsClientOutputs;
+      };
+      data: Passkey;
+      error: null;
     } | {
       data: null;
       error: {
@@ -136,6 +191,8 @@ declare const passkeyClient: () => {
        */
       passkey: (opts?: {
         autoFill?: boolean;
+        extensions?: AuthenticationExtensionsClientInputs;
+        returnWebAuthnResponse?: boolean;
         fetchOptions?: ClientFetchOption;
       } | undefined, options?: ClientFetchOption | undefined) => Promise<{
         data: null;
@@ -150,6 +207,27 @@ declare const passkeyClient: () => {
           user: User;
         };
         error: null;
+      } | {
+        webauthn: {
+          response: AuthenticationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: null;
+        error: {
+          message?: string | undefined;
+          status: number;
+          statusText: string;
+        };
+      } | {
+        webauthn: {
+          response: AuthenticationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: {
+          session: Session;
+          user: User;
+        };
+        error: null;
       } | {
         data: null;
         error: {
@@ -176,12 +254,24 @@ declare const passkeyClient: () => {
          * platform and cross-platform allowed, with platform preferred.
          */
         authenticatorAttachment?: "platform" | "cross-platform";
+        /**
+         * Optional context for passkey-first registration flows.
+         */
+        context?: string | null;
+        /**
+         * Optional WebAuthn extensions to include during registration.
+         */
+        extensions?: AuthenticationExtensionsClientInputs;
         /**
          * Try to silently create a passkey with the password manager that the user just signed
          * in with.
          * @default false
          */
         useAutoRegister?: boolean;
+        /**
+         * Return WebAuthn response and extension results.
+         */
+        returnWebAuthnResponse?: boolean;
       } | undefined, fetchOpts?: ClientFetchOption | undefined) => Promise<{
         data: null;
         error: {
@@ -192,6 +282,13 @@ declare const passkeyClient: () => {
       } | {
         data: Passkey;
         error: null;
+      } | {
+        webauthn: {
+          response: RegistrationResponseJSON;
+          clientExtensionResults: AuthenticationExtensionsClientOutputs;
+        };
+        data: Passkey;
+        error: null;
       } | {
         data: null;
         error: {
@@ -218,7 +315,7 @@ declare const passkeyClient: () => {
     "/passkey/authenticate": "POST";
   };
   atomListeners: ({
-    matcher(path: string): path is "/passkey/delete-passkey" | "/passkey/update-passkey" | "/passkey/verify-registration" | "/sign-out";
+    matcher(path: string): path is "/passkey/verify-registration" | "/passkey/delete-passkey" | "/passkey/update-passkey" | "/sign-out";
     signal: "$listPasskeys";
   } | {
     matcher: (path: string) => path is "/passkey/verify-authentication";
@@ -253,7 +350,19 @@ declare const passkeyClient: () => {
       code: "FAILED_TO_UPDATE_PASSKEY";
       message: "Failed to update passkey";
     };
+    readonly SESSION_REQUIRED: {
+      code: "SESSION_REQUIRED";
+      message: "Passkey registration requires an authenticated session";
+    };
+    readonly RESOLVE_USER_REQUIRED: {
+      code: "RESOLVE_USER_REQUIRED";
+      message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+    };
+    readonly RESOLVED_USER_INVALID: {
+      code: "RESOLVED_USER_INVALID";
+      message: "Resolved user is invalid";
+    };
   };
 };
 //#endregion
-export { PASSKEY_ERROR_CODES, Passkey, PasskeyOptions, WebAuthnChallengeValue, getPasskeyActions, passkeyClient };
\ No newline at end of file
+export { PASSKEY_ERROR_CODES, Passkey, PasskeyAuthenticationOptions, PasskeyExtensionsResolver, PasskeyOptions, PasskeyRegistrationOptions, PasskeyRegistrationUser, WebAuthnChallengeValue, getPasskeyActions, passkeyClient };
\ No newline at end of file
diff --git a/dist/client.mjs b/dist/client.mjs
index 1b6cd2b22b7a7516c26a2c447807f94688e3aa90..dbcca14e3dfaa526b17c85c7ed924aebf7f50caa 100644
--- a/dist/client.mjs
+++ b/dist/client.mjs
@@ -1,4 +1,4 @@
-import { t as PASSKEY_ERROR_CODES } from "./error-codes-VuR_tYBt.mjs";
+import { t as PASSKEY_ERROR_CODES } from "./error-codes-Bfg5KAPi.mjs";
 import { WebAuthnError, startAuthentication, startRegistration } from "@simplewebauthn/browser";
 import { useAuthQuery } from "better-auth/client";
 import { atom } from "nanostores";
@@ -12,11 +12,19 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 		});
 		if (!response.data) return response;
 		try {
+			const mergedExtensions = response.data.extensions || opts?.extensions ? {
+				...response.data.extensions || {},
+				...opts?.extensions || {}
+			} : void 0;
+			const res = await startAuthentication({
+				optionsJSON: {
+					...response.data,
+					extensions: mergedExtensions
+				},
+				useBrowserAutofill: opts?.autoFill
+			});
 			const verified = await $fetch("/passkey/verify-authentication", {
-				body: { response: await startAuthentication({
-					optionsJSON: response.data,
-					useBrowserAutofill: opts?.autoFill
-				}) },
+				body: { response: res },
 				...opts?.fetchOptions,
 				...options,
 				method: "POST",
@@ -24,6 +32,13 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			});
 			$listPasskeys.set(Math.random());
 			$store.notify("$sessionSignal");
+			if (opts?.returnWebAuthnResponse) return {
+				...verified,
+				webauthn: {
+					response: res,
+					clientExtensionResults: res.clientExtensionResults
+				}
+			};
 			return verified;
 		} catch (err) {
 			console.error(`[Better Auth] Error verifying passkey`, err);
@@ -43,14 +58,22 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			method: "GET",
 			query: {
 				...opts?.authenticatorAttachment && { authenticatorAttachment: opts.authenticatorAttachment },
-				...opts?.name && { name: opts.name }
+				...opts?.name && { name: opts.name },
+				...opts?.context && { context: opts.context }
 			},
 			throw: false
 		});
 		if (!options.data) return options;
 		try {
+			const mergedExtensions = options.data.extensions || opts?.extensions ? {
+				...options.data.extensions || {},
+				...opts?.extensions || {}
+			} : void 0;
 			const res = await startRegistration({
-				optionsJSON: options.data,
+				optionsJSON: {
+					...options.data,
+					extensions: mergedExtensions
+				},
 				useAutoRegister: opts?.useAutoRegister
 			});
 			const verified = await $fetch("/passkey/verify-registration", {
@@ -65,6 +88,13 @@ const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
 			});
 			if (!verified.data) return verified;
 			$listPasskeys.set(Math.random());
+			if (opts?.returnWebAuthnResponse) return {
+				...verified,
+				webauthn: {
+					response: res,
+					clientExtensionResults: res.clientExtensionResults
+				}
+			};
 			return verified;
 		} catch (e) {
 			if (e instanceof WebAuthnError) {
diff --git a/dist/error-codes-Bfg5KAPi.mjs b/dist/error-codes-Bfg5KAPi.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..5d2ef818a84ce75510fa320b68d19384fdcc7de5
--- /dev/null
+++ b/dist/error-codes-Bfg5KAPi.mjs
@@ -0,0 +1,18 @@
+import { defineErrorCodes } from "@better-auth/core/utils";
+
+//#region src/error-codes.ts
+const PASSKEY_ERROR_CODES = defineErrorCodes({
+	CHALLENGE_NOT_FOUND: "Challenge not found",
+	YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY: "You are not allowed to register this passkey",
+	FAILED_TO_VERIFY_REGISTRATION: "Failed to verify registration",
+	PASSKEY_NOT_FOUND: "Passkey not found",
+	AUTHENTICATION_FAILED: "Authentication failed",
+	UNABLE_TO_CREATE_SESSION: "Unable to create session",
+	FAILED_TO_UPDATE_PASSKEY: "Failed to update passkey",
+	SESSION_REQUIRED: "Passkey registration requires an authenticated session",
+	RESOLVE_USER_REQUIRED: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false",
+	RESOLVED_USER_INVALID: "Resolved user is invalid"
+});
+
+//#endregion
+export { PASSKEY_ERROR_CODES as t };
\ No newline at end of file
diff --git a/dist/index-D_qGBnrU.d.mts b/dist/index-D_qGBnrU.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..dd68529d4c7f03dbb43ef23369702c10bd3f276e
--- /dev/null
+++ b/dist/index-D_qGBnrU.d.mts
@@ -0,0 +1,813 @@
+import * as _simplewebauthn_server0 from "@simplewebauthn/server";
+import { AuthenticationExtensionsClientInputs, AuthenticationResponseJSON, CredentialDeviceType, RegistrationResponseJSON, VerifiedAuthenticationResponse, VerifiedRegistrationResponse } from "@simplewebauthn/server";
+import * as zod0 from "zod";
+import { GenericEndpointContext } from "@better-auth/core";
+import { InferOptionSchema } from "better-auth/types";
+import * as better_call0 from "better-call";
+import * as better_auth0 from "better-auth";
+
+//#region src/schema.d.ts
+declare const schema: {
+  passkey: {
+    fields: {
+      name: {
+        type: "string";
+        required: false;
+      };
+      publicKey: {
+        type: "string";
+        required: true;
+      };
+      userId: {
+        type: "string";
+        references: {
+          model: string;
+          field: string;
+        };
+        required: true;
+        index: true;
+      };
+      credentialID: {
+        type: "string";
+        required: true;
+        index: true;
+      };
+      counter: {
+        type: "number";
+        required: true;
+      };
+      deviceType: {
+        type: "string";
+        required: true;
+      };
+      backedUp: {
+        type: "boolean";
+        required: true;
+      };
+      transports: {
+        type: "string";
+        required: false;
+      };
+      createdAt: {
+        type: "date";
+        required: false;
+      };
+      aaguid: {
+        type: "string";
+        required: false;
+      };
+    };
+  };
+};
+//#endregion
+//#region src/types.d.ts
+/**
+ * @internal
+ */
+interface WebAuthnChallengeValue {
+  expectedChallenge: string;
+  userData: {
+    id: string;
+    name?: string | undefined;
+    displayName?: string | undefined;
+  };
+  context?: string | null;
+}
+type Awaitable<T> = T | Promise<T>;
+interface PasskeyRegistrationUser {
+  id: string;
+  name: string;
+  displayName?: string | undefined;
+}
+type PasskeyExtensionsResolver = AuthenticationExtensionsClientInputs | ((args: {
+  ctx: GenericEndpointContext;
+}) => Awaitable<AuthenticationExtensionsClientInputs | undefined>);
+interface PasskeyRegistrationOptions {
+  /**
+   * Require an authenticated session for passkey registration.
+   *
+   * @default true
+   */
+  requireSession?: boolean | undefined;
+  /**
+   * Resolve the user when session is not available.
+   * Required when `requireSession` is false and no session exists.
+   */
+  resolveUser?: ((args: {
+    ctx: GenericEndpointContext;
+    context?: string | null | undefined;
+  }) => Awaitable<PasskeyRegistrationUser>) | undefined;
+  /**
+   * Callback after a successful registration verification.
+   * Useful for user linking or auditing.
+   */
+  afterVerification?: ((args: {
+    ctx: GenericEndpointContext;
+    verification: VerifiedRegistrationResponse;
+    user: PasskeyRegistrationUser;
+    clientData: RegistrationResponseJSON;
+    context?: string | null | undefined;
+  }) => Awaitable<{
+    userId?: string;
+  } | void>) | undefined;
+  /**
+   * Optional WebAuthn extensions to include in registration options.
+   */
+  extensions?: PasskeyExtensionsResolver | undefined;
+}
+interface PasskeyAuthenticationOptions {
+  /**
+   * Optional WebAuthn extensions to include in authentication options.
+   */
+  extensions?: PasskeyExtensionsResolver | undefined;
+  /**
+   * Callback after a successful authentication verification.
+   */
+  afterVerification?: ((args: {
+    ctx: GenericEndpointContext;
+    verification: VerifiedAuthenticationResponse;
+    clientData: AuthenticationResponseJSON;
+  }) => Awaitable<void>) | undefined;
+}
+interface PasskeyOptions {
+  /**
+   * A unique identifier for your website. 'localhost' is okay for
+   * local dev
+   *
+   * @default "localhost"
+   */
+  rpID?: string | undefined;
+  /**
+   * Human-readable title for your website
+   *
+   * @default "Better Auth"
+   */
+  rpName?: string | undefined;
+  /**
+   * The URL at which registrations and authentications should occur.
+   * `http://localhost` and `http://localhost:PORT` are also valid.
+   * Do NOT include any trailing /
+   *
+   * if this isn't provided. The client itself will
+   * pass this value.
+   */
+  origin?: (string | string[] | null) | undefined;
+  /**
+   * Allow customization of the authenticatorSelection options
+   * during passkey registration.
+   */
+  authenticatorSelection?: AuthenticatorSelectionCriteria | undefined;
+  /**
+   * Advanced options
+   */
+  advanced?: {
+    /**
+     * Cookie name for storing WebAuthn challenge ID during authentication flow
+     *
+     * @default "better-auth-passkey"
+     */
+    webAuthnChallengeCookie?: string;
+  } | undefined;
+  /**
+   * Schema for the passkey model
+   */
+  schema?: InferOptionSchema<typeof schema> | undefined;
+  /**
+   * Registration behavior overrides
+   */
+  registration?: PasskeyRegistrationOptions | undefined;
+  /**
+   * Authentication behavior overrides
+   */
+  authentication?: PasskeyAuthenticationOptions | undefined;
+}
+type Passkey = {
+  id: string;
+  name?: string | undefined;
+  publicKey: string;
+  userId: string;
+  credentialID: string;
+  counter: number;
+  deviceType: CredentialDeviceType;
+  backedUp: boolean;
+  transports?: string | undefined;
+  createdAt: Date;
+  aaguid?: string | undefined;
+};
+//#endregion
+//#region src/index.d.ts
+declare module "@better-auth/core" {
+  interface BetterAuthPluginRegistry<Auth, Context> {
+    passkey: {
+      creator: typeof passkey;
+    };
+  }
+}
+declare const passkey: (options?: PasskeyOptions | undefined) => {
+  id: "passkey";
+  endpoints: {
+    generatePasskeyRegistrationOptions: better_call0.StrictEndpoint<"/passkey/generate-register-options", {
+      method: "GET";
+      use: ((inputContext: better_call0.MiddlewareInputContext<better_call0.MiddlewareOptions>) => Promise<{
+        session: {
+          session: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            userId: string;
+            expiresAt: Date;
+            token: string;
+            ipAddress?: string | null | undefined;
+            userAgent?: string | null | undefined;
+          };
+          user: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            email: string;
+            emailVerified: boolean;
+            name: string;
+            image?: string | null | undefined;
+          };
+        };
+      }>)[];
+      query: zod0.ZodOptional<zod0.ZodObject<{
+        authenticatorAttachment: zod0.ZodOptional<zod0.ZodEnum<{
+          platform: "platform";
+          "cross-platform": "cross-platform";
+        }>>;
+        name: zod0.ZodOptional<zod0.ZodString>;
+        context: zod0.ZodOptional<zod0.ZodString>;
+      }, better_auth0.$strip>>;
+      metadata: {
+        openapi: {
+          operationId: string;
+          description: string;
+          responses: {
+            200: {
+              description: string;
+              parameters: {
+                query: {
+                  authenticatorAttachment: {
+                    description: string;
+                    required: boolean;
+                  };
+                  name: {
+                    description: string;
+                    required: boolean;
+                  };
+                  context: {
+                    description: string;
+                    required: boolean;
+                  };
+                };
+              };
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "object";
+                    properties: {
+                      challenge: {
+                        type: string;
+                      };
+                      rp: {
+                        type: string;
+                        properties: {
+                          name: {
+                            type: string;
+                          };
+                          id: {
+                            type: string;
+                          };
+                        };
+                      };
+                      user: {
+                        type: string;
+                        properties: {
+                          id: {
+                            type: string;
+                          };
+                          name: {
+                            type: string;
+                          };
+                          displayName: {
+                            type: string;
+                          };
+                        };
+                      };
+                      pubKeyCredParams: {
+                        type: string;
+                        items: {
+                          type: string;
+                          properties: {
+                            type: {
+                              type: string;
+                            };
+                            alg: {
+                              type: string;
+                            };
+                          };
+                        };
+                      };
+                      timeout: {
+                        type: string;
+                      };
+                      excludeCredentials: {
+                        type: string;
+                        items: {
+                          type: string;
+                          properties: {
+                            id: {
+                              type: string;
+                            };
+                            type: {
+                              type: string;
+                            };
+                            transports: {
+                              type: string;
+                              items: {
+                                type: string;
+                              };
+                            };
+                          };
+                        };
+                      };
+                      authenticatorSelection: {
+                        type: string;
+                        properties: {
+                          authenticatorAttachment: {
+                            type: string;
+                          };
+                          requireResidentKey: {
+                            type: string;
+                          };
+                          userVerification: {
+                            type: string;
+                          };
+                        };
+                      };
+                      attestation: {
+                        type: string;
+                      };
+                      extensions: {
+                        type: string;
+                      };
+                    };
+                  };
+                };
+              };
+            };
+          };
+        };
+      };
+    }, _simplewebauthn_server0.PublicKeyCredentialCreationOptionsJSON>;
+    generatePasskeyAuthenticationOptions: better_call0.StrictEndpoint<"/passkey/generate-authenticate-options", {
+      method: "GET";
+      metadata: {
+        openapi: {
+          operationId: string;
+          description: string;
+          responses: {
+            200: {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "object";
+                    properties: {
+                      challenge: {
+                        type: string;
+                      };
+                      rp: {
+                        type: string;
+                        properties: {
+                          name: {
+                            type: string;
+                          };
+                          id: {
+                            type: string;
+                          };
+                        };
+                      };
+                      user: {
+                        type: string;
+                        properties: {
+                          id: {
+                            type: string;
+                          };
+                          name: {
+                            type: string;
+                          };
+                          displayName: {
+                            type: string;
+                          };
+                        };
+                      };
+                      timeout: {
+                        type: string;
+                      };
+                      allowCredentials: {
+                        type: string;
+                        items: {
+                          type: string;
+                          properties: {
+                            id: {
+                              type: string;
+                            };
+                            type: {
+                              type: string;
+                            };
+                            transports: {
+                              type: string;
+                              items: {
+                                type: string;
+                              };
+                            };
+                          };
+                        };
+                      };
+                      userVerification: {
+                        type: string;
+                      };
+                      authenticatorSelection: {
+                        type: string;
+                        properties: {
+                          authenticatorAttachment: {
+                            type: string;
+                          };
+                          requireResidentKey: {
+                            type: string;
+                          };
+                          userVerification: {
+                            type: string;
+                          };
+                        };
+                      };
+                      extensions: {
+                        type: string;
+                      };
+                    };
+                  };
+                };
+              };
+            };
+          };
+        };
+      };
+    }, _simplewebauthn_server0.PublicKeyCredentialRequestOptionsJSON>;
+    verifyPasskeyRegistration: better_call0.StrictEndpoint<"/passkey/verify-registration", {
+      method: "POST";
+      body: zod0.ZodObject<{
+        response: zod0.ZodAny;
+        name: zod0.ZodOptional<zod0.ZodString>;
+      }, better_auth0.$strip>;
+      use: ((inputContext: better_call0.MiddlewareInputContext<better_call0.MiddlewareOptions>) => Promise<{
+        session: {
+          session: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            userId: string;
+            expiresAt: Date;
+            token: string;
+            ipAddress?: string | null | undefined;
+            userAgent?: string | null | undefined;
+          };
+          user: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            email: string;
+            emailVerified: boolean;
+            name: string;
+            image?: string | null | undefined;
+          };
+        };
+      }>)[];
+      metadata: {
+        openapi: {
+          operationId: string;
+          description: string;
+          responses: {
+            200: {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    $ref: string;
+                  };
+                };
+              };
+            };
+            400: {
+              description: string;
+            };
+          };
+        };
+      };
+    }, Passkey | null>;
+    verifyPasskeyAuthentication: better_call0.StrictEndpoint<"/passkey/verify-authentication", {
+      method: "POST";
+      body: zod0.ZodObject<{
+        response: zod0.ZodRecord<zod0.ZodAny, zod0.ZodAny>;
+      }, better_auth0.$strip>;
+      metadata: {
+        openapi: {
+          operationId: string;
+          description: string;
+          responses: {
+            200: {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "object";
+                    properties: {
+                      session: {
+                        $ref: string;
+                      };
+                      user: {
+                        $ref: string;
+                      };
+                    };
+                  };
+                };
+              };
+            };
+          };
+        };
+        $Infer: {
+          body: {
+            response: _simplewebauthn_server0.AuthenticationResponseJSON;
+          };
+        };
+      };
+    }, {
+      session: {
+        id: string;
+        createdAt: Date;
+        updatedAt: Date;
+        userId: string;
+        expiresAt: Date;
+        token: string;
+        ipAddress?: string | null | undefined;
+        userAgent?: string | null | undefined;
+      };
+    }>;
+    listPasskeys: better_call0.StrictEndpoint<"/passkey/list-user-passkeys", {
+      method: "GET";
+      use: ((inputContext: better_call0.MiddlewareInputContext<better_call0.MiddlewareOptions>) => Promise<{
+        session: {
+          session: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            userId: string;
+            expiresAt: Date;
+            token: string;
+            ipAddress?: string | null | undefined;
+            userAgent?: string | null | undefined;
+          };
+          user: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            email: string;
+            emailVerified: boolean;
+            name: string;
+            image?: string | null | undefined;
+          };
+        };
+      }>)[];
+      metadata: {
+        openapi: {
+          description: string;
+          responses: {
+            "200": {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "array";
+                    items: {
+                      $ref: string;
+                      required: string[];
+                    };
+                    description: string;
+                  };
+                };
+              };
+            };
+          };
+        };
+      };
+    }, Passkey[]>;
+    deletePasskey: better_call0.StrictEndpoint<"/passkey/delete-passkey", {
+      method: "POST";
+      body: zod0.ZodObject<{
+        id: zod0.ZodString;
+      }, better_auth0.$strip>;
+      use: ((inputContext: better_call0.MiddlewareInputContext<better_call0.MiddlewareOptions>) => Promise<{
+        session: {
+          session: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            userId: string;
+            expiresAt: Date;
+            token: string;
+            ipAddress?: string | null | undefined;
+            userAgent?: string | null | undefined;
+          };
+          user: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            email: string;
+            emailVerified: boolean;
+            name: string;
+            image?: string | null | undefined;
+          };
+        };
+      }>)[];
+      metadata: {
+        openapi: {
+          description: string;
+          responses: {
+            "200": {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "object";
+                    properties: {
+                      status: {
+                        type: string;
+                        description: string;
+                      };
+                    };
+                    required: string[];
+                  };
+                };
+              };
+            };
+          };
+        };
+      };
+    }, {
+      status: boolean;
+    }>;
+    updatePasskey: better_call0.StrictEndpoint<"/passkey/update-passkey", {
+      method: "POST";
+      body: zod0.ZodObject<{
+        id: zod0.ZodString;
+        name: zod0.ZodString;
+      }, better_auth0.$strip>;
+      use: ((inputContext: better_call0.MiddlewareInputContext<better_call0.MiddlewareOptions>) => Promise<{
+        session: {
+          session: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            userId: string;
+            expiresAt: Date;
+            token: string;
+            ipAddress?: string | null | undefined;
+            userAgent?: string | null | undefined;
+          };
+          user: Record<string, any> & {
+            id: string;
+            createdAt: Date;
+            updatedAt: Date;
+            email: string;
+            emailVerified: boolean;
+            name: string;
+            image?: string | null | undefined;
+          };
+        };
+      }>)[];
+      metadata: {
+        openapi: {
+          description: string;
+          responses: {
+            "200": {
+              description: string;
+              content: {
+                "application/json": {
+                  schema: {
+                    type: "object";
+                    properties: {
+                      passkey: {
+                        $ref: string;
+                      };
+                    };
+                    required: string[];
+                  };
+                };
+              };
+            };
+          };
+        };
+      };
+    }, {
+      passkey: Passkey;
+    }>;
+  };
+  schema: {
+    passkey: {
+      fields: {
+        name: {
+          type: "string";
+          required: false;
+        };
+        publicKey: {
+          type: "string";
+          required: true;
+        };
+        userId: {
+          type: "string";
+          references: {
+            model: string;
+            field: string;
+          };
+          required: true;
+          index: true;
+        };
+        credentialID: {
+          type: "string";
+          required: true;
+          index: true;
+        };
+        counter: {
+          type: "number";
+          required: true;
+        };
+        deviceType: {
+          type: "string";
+          required: true;
+        };
+        backedUp: {
+          type: "boolean";
+          required: true;
+        };
+        transports: {
+          type: "string";
+          required: false;
+        };
+        createdAt: {
+          type: "date";
+          required: false;
+        };
+        aaguid: {
+          type: "string";
+          required: false;
+        };
+      };
+    };
+  };
+  $ERROR_CODES: {
+    readonly CHALLENGE_NOT_FOUND: {
+      code: "CHALLENGE_NOT_FOUND";
+      message: "Challenge not found";
+    };
+    readonly YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY: {
+      code: "YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY";
+      message: "You are not allowed to register this passkey";
+    };
+    readonly FAILED_TO_VERIFY_REGISTRATION: {
+      code: "FAILED_TO_VERIFY_REGISTRATION";
+      message: "Failed to verify registration";
+    };
+    readonly PASSKEY_NOT_FOUND: {
+      code: "PASSKEY_NOT_FOUND";
+      message: "Passkey not found";
+    };
+    readonly AUTHENTICATION_FAILED: {
+      code: "AUTHENTICATION_FAILED";
+      message: "Authentication failed";
+    };
+    readonly UNABLE_TO_CREATE_SESSION: {
+      code: "UNABLE_TO_CREATE_SESSION";
+      message: "Unable to create session";
+    };
+    readonly FAILED_TO_UPDATE_PASSKEY: {
+      code: "FAILED_TO_UPDATE_PASSKEY";
+      message: "Failed to update passkey";
+    };
+    readonly SESSION_REQUIRED: {
+      code: "SESSION_REQUIRED";
+      message: "Passkey registration requires an authenticated session";
+    };
+    readonly RESOLVE_USER_REQUIRED: {
+      code: "RESOLVE_USER_REQUIRED";
+      message: "Passkey registration requires either an authenticated session or a resolveUser callback when requireSession is false";
+    };
+    readonly RESOLVED_USER_INVALID: {
+      code: "RESOLVED_USER_INVALID";
+      message: "Resolved user is invalid";
+    };
+  };
+  options: PasskeyOptions | undefined;
+};
+//#endregion
+export { PasskeyOptions as a, WebAuthnChallengeValue as c, PasskeyExtensionsResolver as i, Passkey as n, PasskeyRegistrationOptions as o, PasskeyAuthenticationOptions as r, PasskeyRegistrationUser as s, passkey as t };
\ No newline at end of file
diff --git a/dist/index.d.mts b/dist/index.d.mts
index 2c4c91970876083c9b59a2fd1015056dae286637..49b57b51e0e40502157a0ef35393043da7bb119c 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,2 +1,2 @@
-import { n as Passkey, r as PasskeyOptions, t as passkey } from "./index-CdIR3B4H.mjs";
+import { a as PasskeyOptions, n as Passkey, t as passkey } from "./index-D_qGBnrU.mjs";
 export { Passkey, PasskeyOptions, passkey };
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 0c0dba9f9aa88e74d101680739721bd7cbfdea6f..72d874509da9ca956b363ab31cae1b6ca56f5cd3 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,4 +1,4 @@
-import { t as PASSKEY_ERROR_CODES } from "./error-codes-VuR_tYBt.mjs";
+import { t as PASSKEY_ERROR_CODES } from "./error-codes-Bfg5KAPi.mjs";
 import { mergeSchema } from "better-auth/db";
 import { createAuthEndpoint } from "@better-auth/core/api";
 import { APIError } from "@better-auth/core/error";
@@ -16,135 +16,182 @@ function getRpID(options, baseURL) {
 
 //#endregion
 //#region src/routes.ts
+const resolveExtensions = async (extensions, ctx) => {
+	if (!extensions) return;
+	if (typeof extensions === "function") return await extensions({ ctx });
+	return extensions;
+};
+const resolveRegistrationUser = async (opts, ctx) => {
+	if (opts.registration?.requireSession ?? true) {
+		const session$1 = ctx.context?.session;
+		if (!session$1?.user?.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.SESSION_REQUIRED);
+		const sessionName = session$1.user.email || session$1.user.id;
+		return {
+			id: session$1.user.id,
+			name: sessionName,
+			displayName: sessionName
+		};
+	}
+	const session = await getSessionFromCtx(ctx);
+	if (session?.user?.id) {
+		const sessionName = session.user.email || session.user.id;
+		return {
+			id: session.user.id,
+			name: sessionName,
+			displayName: sessionName
+		};
+	}
+	if (!opts.registration?.resolveUser) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVE_USER_REQUIRED);
+	const resolvedUser = await opts.registration.resolveUser({
+		ctx,
+		context: ctx.query?.context ?? null
+	});
+	if (!resolvedUser?.id || !resolvedUser?.name) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVED_USER_INVALID);
+	return resolvedUser;
+};
 const generatePasskeyQuerySchema = z.object({
 	authenticatorAttachment: z.enum(["platform", "cross-platform"]).optional(),
-	name: z.string().optional()
+	name: z.string().optional(),
+	context: z.string().optional()
 }).optional();
-const generatePasskeyRegistrationOptions = (opts, { maxAgeInSeconds, expirationTime }) => createAuthEndpoint("/passkey/generate-register-options", {
-	method: "GET",
-	use: [freshSessionMiddleware],
-	query: generatePasskeyQuerySchema,
-	metadata: { openapi: {
-		operationId: "generatePasskeyRegistrationOptions",
-		description: "Generate registration options for a new passkey",
-		responses: { 200: {
-			description: "Success",
-			parameters: { query: {
-				authenticatorAttachment: {
-					description: `Type of authenticator to use for registration.
+const generatePasskeyRegistrationOptions = (opts, { maxAgeInSeconds, expirationTime }) => {
+	return createAuthEndpoint("/passkey/generate-register-options", {
+		method: "GET",
+		use: opts.registration?.requireSession ?? true ? [freshSessionMiddleware] : [],
+		query: generatePasskeyQuerySchema,
+		metadata: { openapi: {
+			operationId: "generatePasskeyRegistrationOptions",
+			description: "Generate registration options for a new passkey",
+			responses: { 200: {
+				description: "Success",
+				parameters: { query: {
+					authenticatorAttachment: {
+						description: `Type of authenticator to use for registration.
                           "platform" for device-specific authenticators,
                           "cross-platform" for authenticators that can be used across devices.`,
-					required: false
-				},
-				name: {
-					description: `Optional custom name for the passkey.
-                          This can help identify the passkey when managing multiple credentials.`,
-					required: false
-				}
-			} },
-			content: { "application/json": { schema: {
-				type: "object",
-				properties: {
-					challenge: { type: "string" },
-					rp: {
-						type: "object",
-						properties: {
-							name: { type: "string" },
-							id: { type: "string" }
-						}
+						required: false
 					},
-					user: {
-						type: "object",
-						properties: {
-							id: { type: "string" },
-							name: { type: "string" },
-							displayName: { type: "string" }
-						}
+					name: {
+						description: `Optional custom name for the passkey.
+                          This can help identify the passkey when managing multiple credentials.`,
+						required: false
 					},
-					pubKeyCredParams: {
-						type: "array",
-						items: {
+					context: {
+						description: "Optional context for passkey-first registration flows.",
+						required: false
+					}
+				} },
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						challenge: { type: "string" },
+						rp: {
 							type: "object",
 							properties: {
-								type: { type: "string" },
-								alg: { type: "number" }
+								name: { type: "string" },
+								id: { type: "string" }
 							}
-						}
-					},
-					timeout: { type: "number" },
-					excludeCredentials: {
-						type: "array",
-						items: {
+						},
+						user: {
 							type: "object",
 							properties: {
 								id: { type: "string" },
-								type: { type: "string" },
-								transports: {
-									type: "array",
-									items: { type: "string" }
+								name: { type: "string" },
+								displayName: { type: "string" }
+							}
+						},
+						pubKeyCredParams: {
+							type: "array",
+							items: {
+								type: "object",
+								properties: {
+									type: { type: "string" },
+									alg: { type: "number" }
 								}
 							}
-						}
-					},
-					authenticatorSelection: {
-						type: "object",
-						properties: {
-							authenticatorAttachment: { type: "string" },
-							requireResidentKey: { type: "boolean" },
-							userVerification: { type: "string" }
-						}
-					},
-					attestation: { type: "string" },
-					extensions: { type: "object" }
-				}
-			} } }
+						},
+						timeout: { type: "number" },
+						excludeCredentials: {
+							type: "array",
+							items: {
+								type: "object",
+								properties: {
+									id: { type: "string" },
+									type: { type: "string" },
+									transports: {
+										type: "array",
+										items: { type: "string" }
+									}
+								}
+							}
+						},
+						authenticatorSelection: {
+							type: "object",
+							properties: {
+								authenticatorAttachment: { type: "string" },
+								requireResidentKey: { type: "boolean" },
+								userVerification: { type: "string" }
+							}
+						},
+						attestation: { type: "string" },
+						extensions: { type: "object" }
+					}
+				} } }
+			} }
 		} }
-	} }
-}, async (ctx) => {
-	const { session } = ctx.context;
-	const userPasskeys = await ctx.context.adapter.findMany({
-		model: "passkey",
-		where: [{
-			field: "userId",
-			value: session.user.id
-		}]
-	});
-	const userID = new TextEncoder().encode(generateRandomString(32, "a-z", "0-9"));
-	let options;
-	options = await generateRegistrationOptions({
-		rpName: opts.rpName || ctx.context.appName,
-		rpID: getRpID(opts, ctx.context.options.baseURL),
-		userID,
-		userName: ctx.query?.name || session.user.email || session.user.id,
-		userDisplayName: session.user.email || session.user.id,
-		attestationType: "none",
-		excludeCredentials: userPasskeys.map((passkey$1) => ({
-			id: passkey$1.credentialID,
-			transports: passkey$1.transports?.split(",")
-		})),
-		authenticatorSelection: {
-			residentKey: "preferred",
-			userVerification: "preferred",
-			...opts.authenticatorSelection || {},
-			...ctx.query?.authenticatorAttachment ? { authenticatorAttachment: ctx.query.authenticatorAttachment } : {}
-		}
-	});
-	const verificationToken = generateRandomString(32);
-	const webAuthnCookie = ctx.context.createAuthCookie(opts.advanced.webAuthnChallengeCookie);
-	await ctx.setSignedCookie(webAuthnCookie.name, verificationToken, ctx.context.secret, {
-		...webAuthnCookie.attributes,
-		maxAge: maxAgeInSeconds
-	});
-	await ctx.context.internalAdapter.createVerificationValue({
-		identifier: verificationToken,
-		value: JSON.stringify({
-			expectedChallenge: options.challenge,
-			userData: { id: session.user.id }
-		}),
-		expiresAt: expirationTime
+	}, async (ctx) => {
+		const user = await resolveRegistrationUser(opts, ctx);
+		const userPasskeys = await ctx.context.adapter.findMany({
+			model: "passkey",
+			where: [{
+				field: "userId",
+				value: user.id
+			}]
+		});
+		const registrationExtensions = await resolveExtensions(opts.registration?.extensions, ctx);
+		const userID = new TextEncoder().encode(generateRandomString(32, "a-z", "0-9"));
+		let options;
+		options = await generateRegistrationOptions({
+			rpName: opts.rpName || ctx.context.appName,
+			rpID: getRpID(opts, ctx.context.options.baseURL),
+			userID,
+			userName: ctx.query?.name || user.name || user.id,
+			userDisplayName: user.displayName || user.name || user.id,
+			attestationType: "none",
+			excludeCredentials: userPasskeys.map((passkey$1) => ({
+				id: passkey$1.credentialID,
+				transports: passkey$1.transports?.split(",")
+			})),
+			authenticatorSelection: {
+				residentKey: "preferred",
+				userVerification: "preferred",
+				...opts.authenticatorSelection || {},
+				...ctx.query?.authenticatorAttachment ? { authenticatorAttachment: ctx.query.authenticatorAttachment } : {}
+			},
+			extensions: registrationExtensions
+		});
+		const verificationToken = generateRandomString(32);
+		const webAuthnCookie = ctx.context.createAuthCookie(opts.advanced.webAuthnChallengeCookie);
+		await ctx.setSignedCookie(webAuthnCookie.name, verificationToken, ctx.context.secret, {
+			...webAuthnCookie.attributes,
+			maxAge: maxAgeInSeconds
+		});
+		await ctx.context.internalAdapter.createVerificationValue({
+			identifier: verificationToken,
+			value: JSON.stringify({
+				expectedChallenge: options.challenge,
+				userData: {
+					id: user.id,
+					name: user.name,
+					displayName: user.displayName
+				},
+				context: ctx.query?.context ?? null
+			}),
+			expiresAt: expirationTime
+		});
+		return ctx.json(options, { status: 200 });
 	});
-	return ctx.json(options, { status: 200 });
-});
+};
 const generatePasskeyAuthenticationOptions = (opts, { maxAgeInSeconds, expirationTime }) => createAuthEndpoint("/passkey/generate-authenticate-options", {
 	method: "GET",
 	metadata: { openapi: {
@@ -210,9 +257,11 @@ const generatePasskeyAuthenticationOptions = (opts, { maxAgeInSeconds, expiratio
 			value: session.user.id
 		}]
 	});
+	const authenticationExtensions = await resolveExtensions(opts.authentication?.extensions, ctx);
 	const options = await generateAuthenticationOptions({
 		rpID: getRpID(opts, ctx.context.options.baseURL),
 		userVerification: "preferred",
+		extensions: authenticationExtensions,
 		...userPasskeys.length ? { allowCredentials: userPasskeys.map((passkey$1) => ({
 			id: passkey$1.credentialID,
 			transports: passkey$1.transports?.split(",")
@@ -239,66 +288,91 @@ const verifyPasskeyRegistrationBodySchema = z.object({
 	response: z.any(),
 	name: z.string().meta({ description: "Name of the passkey" }).optional()
 });
-const verifyPasskeyRegistration = (options) => createAuthEndpoint("/passkey/verify-registration", {
-	method: "POST",
-	body: verifyPasskeyRegistrationBodySchema,
-	use: [freshSessionMiddleware],
-	metadata: { openapi: {
-		operationId: "passkeyVerifyRegistration",
-		description: "Verify registration of a new passkey",
-		responses: {
-			200: {
-				description: "Success",
-				content: { "application/json": { schema: { $ref: "#/components/schemas/Passkey" } } }
-			},
-			400: { description: "Bad request" }
+const verifyPasskeyRegistration = (options) => {
+	const requireSession = options.registration?.requireSession ?? true;
+	return createAuthEndpoint("/passkey/verify-registration", {
+		method: "POST",
+		body: verifyPasskeyRegistrationBodySchema,
+		use: requireSession ? [freshSessionMiddleware] : [],
+		metadata: { openapi: {
+			operationId: "passkeyVerifyRegistration",
+			description: "Verify registration of a new passkey",
+			responses: {
+				200: {
+					description: "Success",
+					content: { "application/json": { schema: { $ref: "#/components/schemas/Passkey" } } }
+				},
+				400: { description: "Bad request" }
+			}
+		} }
+	}, async (ctx) => {
+		const origin = options?.origin || ctx.headers?.get("origin") || "";
+		if (!origin) return ctx.json(null, { status: 400 });
+		const resp = ctx.body.response;
+		const webAuthnCookie = ctx.context.createAuthCookie(options.advanced.webAuthnChallengeCookie);
+		const verificationToken = await ctx.getSignedCookie(webAuthnCookie.name, ctx.context.secret);
+		if (!verificationToken) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.CHALLENGE_NOT_FOUND);
+		const data = await ctx.context.internalAdapter.findVerificationValue(verificationToken);
+		if (!data) return ctx.json(null, { status: 400 });
+		const { expectedChallenge, userData, context } = JSON.parse(data.value);
+		const session = requireSession ? ctx.context.session : await getSessionFromCtx(ctx);
+		if (session?.user?.id && userData.id !== session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
+		try {
+			const verification = await verifyRegistrationResponse({
+				response: resp,
+				expectedChallenge,
+				expectedOrigin: origin,
+				expectedRPID: getRpID(options, ctx.context.options.baseURL),
+				requireUserVerification: false
+			});
+			const { verified, registrationInfo } = verification;
+			if (!verified || !registrationInfo) return ctx.json(null, { status: 400 });
+			const { aaguid, credentialDeviceType, credentialBackedUp, credential } = registrationInfo;
+			const resolvedUser = {
+				id: userData.id,
+				name: userData.name || userData.id,
+				displayName: userData.displayName
+			};
+			let targetUserId = resolvedUser.id;
+			if (options.registration?.afterVerification) {
+				const result = await options.registration.afterVerification({
+					ctx,
+					verification,
+					user: resolvedUser,
+					clientData: resp,
+					context
+				});
+				if (result?.userId) {
+					if (typeof result.userId !== "string" || !result.userId) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.RESOLVED_USER_INVALID);
+					if (session?.user?.id && result.userId !== session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
+					targetUserId = result.userId;
+				}
+			}
+			const pubKey = base64.encode(credential.publicKey);
+			const newPasskey = {
+				name: ctx.body.name,
+				userId: targetUserId,
+				credentialID: credential.id,
+				publicKey: pubKey,
+				counter: credential.counter,
+				deviceType: credentialDeviceType,
+				transports: resp.response.transports.join(","),
+				backedUp: credentialBackedUp,
+				createdAt: /* @__PURE__ */ new Date(),
+				aaguid
+			};
+			const newPasskeyRes = await ctx.context.adapter.create({
+				model: "passkey",
+				data: newPasskey
+			});
+			await ctx.context.internalAdapter.deleteVerificationValue(data.id);
+			return ctx.json(newPasskeyRes, { status: 200 });
+		} catch (e) {
+			ctx.context.logger.error("Failed to verify registration", e);
+			throw APIError.from("INTERNAL_SERVER_ERROR", PASSKEY_ERROR_CODES.FAILED_TO_VERIFY_REGISTRATION);
 		}
-	} }
-}, async (ctx) => {
-	const origin = options?.origin || ctx.headers?.get("origin") || "";
-	if (!origin) return ctx.json(null, { status: 400 });
-	const resp = ctx.body.response;
-	const webAuthnCookie = ctx.context.createAuthCookie(options.advanced.webAuthnChallengeCookie);
-	const verificationToken = await ctx.getSignedCookie(webAuthnCookie.name, ctx.context.secret);
-	if (!verificationToken) throw APIError.from("BAD_REQUEST", PASSKEY_ERROR_CODES.CHALLENGE_NOT_FOUND);
-	const data = await ctx.context.internalAdapter.findVerificationValue(verificationToken);
-	if (!data) return ctx.json(null, { status: 400 });
-	const { expectedChallenge, userData } = JSON.parse(data.value);
-	if (userData.id !== ctx.context.session.user.id) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY);
-	try {
-		const { verified, registrationInfo } = await verifyRegistrationResponse({
-			response: resp,
-			expectedChallenge,
-			expectedOrigin: origin,
-			expectedRPID: getRpID(options, ctx.context.options.baseURL),
-			requireUserVerification: false
-		});
-		if (!verified || !registrationInfo) return ctx.json(null, { status: 400 });
-		const { aaguid, credentialDeviceType, credentialBackedUp, credential } = registrationInfo;
-		const pubKey = base64.encode(credential.publicKey);
-		const newPasskey = {
-			name: ctx.body.name,
-			userId: userData.id,
-			credentialID: credential.id,
-			publicKey: pubKey,
-			counter: credential.counter,
-			deviceType: credentialDeviceType,
-			transports: resp.response.transports.join(","),
-			backedUp: credentialBackedUp,
-			createdAt: /* @__PURE__ */ new Date(),
-			aaguid
-		};
-		const newPasskeyRes = await ctx.context.adapter.create({
-			model: "passkey",
-			data: newPasskey
-		});
-		await ctx.context.internalAdapter.deleteVerificationValue(data.id);
-		return ctx.json(newPasskeyRes, { status: 200 });
-	} catch (e) {
-		ctx.context.logger.error("Failed to verify registration", e);
-		throw APIError.from("INTERNAL_SERVER_ERROR", PASSKEY_ERROR_CODES.FAILED_TO_VERIFY_REGISTRATION);
-	}
-});
+	});
+};
 const verifyPasskeyAuthenticationBodySchema = z.object({ response: z.record(z.any(), z.any()) });
 const verifyPasskeyAuthentication = (options) => createAuthEndpoint("/passkey/verify-authentication", {
 	method: "POST",
@@ -354,6 +428,11 @@ const verifyPasskeyAuthentication = (options) => createAuthEndpoint("/passkey/ve
 		});
 		const { verified } = verification;
 		if (!verified) throw APIError.from("UNAUTHORIZED", PASSKEY_ERROR_CODES.AUTHENTICATION_FAILED);
+		if (options.authentication?.afterVerification) await options.authentication.afterVerification({
+			ctx,
+			verification,
+			clientData: resp
+		});
 		await ctx.context.adapter.update({
 			model: "passkey",
 			where: [{
