/**
 * Server-Side Noir Proof Verification
 *
 * Verifies UltraHonk proofs generated by the browser using bb.js.
 * Uses the Barretenberg API directly (no child processes).
 */

import "server-only";

import type { ProofType } from "./proof-types";

import { createHash } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, rmSync } from "node:fs";
import { createRequire } from "node:module";
import { dirname, join } from "node:path";

import { UltraHonkBackend, UltraHonkVerifierBackend } from "@aztec/bb.js";

import { logger } from "@/lib/logging/logger";
import { recordZkVerifyDuration } from "@/lib/observability/metrics";
import {
  getBarretenberg,
  poseidon2Hash,
} from "@/lib/privacy/crypto/barretenberg";
import ageCircuit from "@/noir-circuits/age_verification/artifacts/age_verification.json";
import docValidityCircuit from "@/noir-circuits/doc_validity/artifacts/doc_validity.json";
import faceMatchCircuit from "@/noir-circuits/face_match/artifacts/face_match.json";
import identityBindingCircuit from "@/noir-circuits/identity_binding/artifacts/identity_binding.json";
import nationalityCircuit from "@/noir-circuits/nationality_membership/artifacts/nationality_membership.json";

const CIRCUITS = {
  age_verification: ageCircuit,
  doc_validity: docValidityCircuit,
  nationality_membership: nationalityCircuit,
  face_match: faceMatchCircuit,
  identity_binding: identityBindingCircuit,
} as const;

const DECIMAL_NUMBER_PATTERN = /^\d+$/;
const HEX_CHARS_PATTERN = /^[0-9a-fA-F]+$/;

interface NoirVerifyInput {
  proof: string; // Base64 encoded Uint8Array
  publicInputs: string[];
  circuitType: ProofType;
}

interface NoirVerifyResult {
  isValid: boolean;
  reason?: string;
  verificationTimeMs: number;
  circuitType: ProofType;
  noirVersion: string | null;
  circuitHash: string | null;
  circuitId: string | null;
  verificationKeyHash: string | null;
  verificationKeyPoseidonHash: string | null;
  bbVersion: string | null;
}

interface CircuitIdentity {
  circuitType: ProofType;
  noirVersion: string | null;
  circuitHash: string | null;
  bbVersion: string | null;
  bytecodeHash: string | null;
  verificationKeyHash: string | null;
  verificationKeyPoseidonHash: string | null;
  publicInputCount: number | null;
  circuitId: string | null;
}

interface VerificationKeyResult {
  verificationKey: string;
  verificationKeyHash: string;
  verificationKeyPoseidonHash: string;
  publicInputCount: number;
  size: number;
}

// CRS cache configuration
const CRS_PATH =
  process.env.BB_CRS_PATH || process.env.CRS_PATH || "/tmp/.bb-crs";
const CRS_FILES = [
  "bn254_g1.dat",
  "bn254_g1.dat.gz",
  "g1.dat",
  "g1.dat.gz",
  "bn254_g2.dat",
];

if (!process.env.CRS_PATH) {
  process.env.CRS_PATH = CRS_PATH;
}

try {
  mkdirSync(CRS_PATH, { recursive: true });
} catch {
  // Best-effort: directory might already exist or be read-only.
}

// Singleton instances (Barretenberg is shared from barretenberg.ts)
let verifierBackend: UltraHonkVerifierBackend | null = null;
let cachedBbJsVersion: string | null | undefined;
let prewarmPromise: Promise<void> | null = null;

// Caches
const vkeyCache = new Map<ProofType, Promise<VerificationKeyResult>>();
const identityCache = new Map<ProofType, Promise<CircuitIdentity>>();
const backendCache = new Map<string, UltraHonkBackend>();

function sha256Hex(input: Uint8Array | string): string {
  return createHash("sha256").update(input).digest("hex");
}

function toFieldHex(bytes: Uint8Array): string {
  return Buffer.from(bytes).toString("hex").padStart(64, "0");
}

function vkBytesToFields(vkBytes: Uint8Array): bigint[] {
  const fields: bigint[] = [];
  for (let offset = 0; offset < vkBytes.length; offset += 32) {
    const chunk = vkBytes.slice(offset, offset + 32);
    fields.push(BigInt(`0x${toFieldHex(chunk)}`));
  }
  return fields;
}

function getPublicInputCountFromVkey(vkBytes: Uint8Array): number {
  if (vkBytes.length < 64) {
    throw new Error("Verification key too small to parse public input count");
  }
  const countHex = toFieldHex(vkBytes.slice(32, 64));
  const count = BigInt(`0x${countHex}`) - BigInt(16);
  if (count < BigInt(0)) {
    throw new Error("Invalid public input count in verification key");
  }
  const asNumber = Number(count);
  if (!Number.isSafeInteger(asNumber)) {
    throw new Error("Public input count exceeds safe integer range");
  }
  return asNumber;
}

function normalizePublicInput(input: string): string {
  const trimmed = input.trim();
  if (!trimmed) {
    return trimmed;
  }
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
    return trimmed;
  }
  if (DECIMAL_NUMBER_PATTERN.test(trimmed)) {
    return trimmed;
  }
  if (HEX_CHARS_PATTERN.test(trimmed)) {
    return `0x${trimmed}`;
  }
  return trimmed;
}

function isInvalidCrsError(error: unknown): boolean {
  const message = error instanceof Error ? error.message : String(error);
  return (
    message.includes("invalid g1_identity") ||
    message.includes("MemBn254CrsFactory")
  );
}

function clearCrsCache(reason: string): void {
  for (const file of CRS_FILES) {
    try {
      rmSync(join(CRS_PATH, file), { force: true });
    } catch {
      // Best effort cleanup.
    }
  }
  backendCache.clear();
  vkeyCache.clear();
  identityCache.clear();
  verifierBackend = null;
  logger.warn({ reason, crsPath: CRS_PATH }, "Cleared CRS cache");
}

async function getVerifierBackend(): Promise<UltraHonkVerifierBackend> {
  if (verifierBackend) {
    return verifierBackend;
  }

  const api = await getBarretenberg();
  verifierBackend = new UltraHonkVerifierBackend(api);
  return verifierBackend;
}

function getCircuitBytecode(circuitType: ProofType): string {
  const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
  const bytecode = circuit?.bytecode;
  if (typeof bytecode !== "string" || !bytecode) {
    throw new Error(`Missing circuit bytecode for ${circuitType}`);
  }
  return bytecode;
}

function getCacheKey(circuitType: ProofType, bytecode: string): string {
  return `${circuitType}:${sha256Hex(bytecode)}`;
}

async function getBackend(circuitType: ProofType): Promise<UltraHonkBackend> {
  const bytecode = getCircuitBytecode(circuitType);
  const cacheKey = getCacheKey(circuitType, bytecode);

  const cached = backendCache.get(cacheKey);
  if (cached) {
    return cached;
  }

  const api = await getBarretenberg();
  const backend = new UltraHonkBackend(bytecode, api);
  backendCache.set(cacheKey, backend);
  return backend;
}

export function getCircuitMetadata(circuitType: ProofType): {
  noirVersion: string | null;
  circuitHash: string | null;
} {
  const circuit = CIRCUITS[circuitType] as unknown as {
    noir_version?: string;
    hash?: string | number;
  };

  return {
    noirVersion: circuit.noir_version ?? null,
    circuitHash:
      circuit.hash === undefined || circuit.hash === null
        ? null
        : String(circuit.hash),
  };
}

export function getBbJsVersion(): string | null {
  if (cachedBbJsVersion !== undefined) {
    return cachedBbJsVersion;
  }

  try {
    const require = createRequire(import.meta.url);
    const entryPath = require.resolve("@aztec/bb.js");

    let currentDir = dirname(entryPath);
    for (let i = 0; i < 10; i++) {
      const pkgPath = join(currentDir, "package.json");
      if (existsSync(pkgPath)) {
        const raw = readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(raw) as { version?: unknown };
        cachedBbJsVersion =
          typeof parsed.version === "string" ? parsed.version : null;
        return cachedBbJsVersion;
      }

      const parent = dirname(currentDir);
      if (parent === currentDir) {
        break;
      }
      currentDir = parent;
    }

    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  } catch {
    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  }
}

export function getCircuitVerificationKey(
  circuitType: ProofType
): Promise<VerificationKeyResult> {
  const existing = vkeyCache.get(circuitType);
  if (existing) {
    return existing;
  }

  const promise = (async (): Promise<VerificationKeyResult> => {
    let backend = await getBackend(circuitType);
    let vkBytes: Uint8Array;

    try {
      vkBytes = await backend.getVerificationKey();
    } catch (error) {
      if (!isInvalidCrsError(error)) {
        throw error;
      }
      clearCrsCache("invalid CRS identity");
      backend = await getBackend(circuitType);
      vkBytes = await backend.getVerificationKey();
    }

    const vkHash = sha256Hex(vkBytes);
    const vkeyPoseidonHash = await poseidon2Hash(vkBytesToFields(vkBytes));
    const publicInputCount = getPublicInputCountFromVkey(vkBytes);

    return {
      verificationKey: Buffer.from(vkBytes).toString("base64"),
      verificationKeyHash: vkHash,
      verificationKeyPoseidonHash: `0x${vkeyPoseidonHash.toString(16).padStart(64, "0")}`,
      publicInputCount,
      size: vkBytes.length,
    };
  })();

  vkeyCache.set(circuitType, promise);
  return promise;
}

export function prewarmVerificationKeys(): Promise<void> {
  if (prewarmPromise) {
    return prewarmPromise;
  }

  prewarmPromise = (async () => {
    const circuitTypes = Object.keys(CIRCUITS) as ProofType[];
    const failures: unknown[] = [];

    for (const circuitType of circuitTypes) {
      try {
        await getCircuitVerificationKey(circuitType);
      } catch (error) {
        failures.push(error);
      }
    }

    if (failures.length) {
      const message = failures
        .map((failure) =>
          failure instanceof Error ? failure.message : String(failure)
        )
        .filter(Boolean)
        .join(", ");
      throw new Error(
        message
          ? `Failed to prewarm verification keys: ${message}`
          : "Failed to prewarm verification keys"
      );
    }
  })();

  return prewarmPromise;
}

export async function warmupCRS(): Promise<void> {
  const startTime = Date.now();
  try {
    await prewarmVerificationKeys();
    logger.info(
      { durationMs: Date.now() - startTime, circuits: Object.keys(CIRCUITS) },
      "ZK verification keys preloaded (CRS cached)"
    );
  } catch (error) {
    logger.warn(
      {
        err: error,
        durationMs: Date.now() - startTime,
        circuits: Object.keys(CIRCUITS),
      },
      "ZK verification key warmup failed"
    );
    if (process.env.ZK_WARMUP_STRICT === "true") {
      throw error;
    }
  }
}

export function getCircuitIdentity(
  circuitType: ProofType
): Promise<CircuitIdentity> {
  const existing = identityCache.get(circuitType);
  if (existing) {
    return existing;
  }

  const identityPromise = (async (): Promise<CircuitIdentity> => {
    const bbVersion = getBbJsVersion();
    const meta = getCircuitMetadata(circuitType);
    const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
    const bytecode =
      circuit && typeof circuit.bytecode === "string" ? circuit.bytecode : null;

    try {
      const vk = await getCircuitVerificationKey(circuitType);
      const verificationKeyHash = vk.verificationKeyHash;
      const verificationKeyPoseidonHash = vk.verificationKeyPoseidonHash;
      const publicInputCount = vk.publicInputCount;
      const bytecodeHash = bytecode ? sha256Hex(bytecode) : null;
      const circuitId = `ultrahonk:${verificationKeyHash}`;

      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash,
        verificationKeyHash,
        verificationKeyPoseidonHash,
        publicInputCount,
        circuitId,
      };
    } catch {
      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash: bytecode ? sha256Hex(bytecode) : null,
        verificationKeyHash: null,
        verificationKeyPoseidonHash: null,
        publicInputCount: null,
        circuitId: null,
      };
    }
  })();

  identityCache.set(circuitType, identityPromise);
  return identityPromise;
}

/**
 * Verify a ZK proof using UltraHonk backend
 *
 * @param input - Proof data including base64-encoded proof bytes and public inputs
 * @returns Verification result with timing information
 */
export async function verifyNoirProof(
  input: NoirVerifyInput
): Promise<NoirVerifyResult> {
  const start = performance.now();
  const identity = await getCircuitIdentity(input.circuitType);
  const bbVersion = getBbJsVersion();

  try {
    const publicInputs = input.publicInputs.map(normalizePublicInput);
    const proofBytes = Buffer.from(input.proof, "base64");
    const vkResult = await getCircuitVerificationKey(input.circuitType);

    if (publicInputs.length !== vkResult.publicInputCount) {
      const verificationTimeMs = performance.now() - start;
      recordZkVerifyDuration(verificationTimeMs, {
        circuit_type: input.circuitType,
        result: "error",
      });
      return {
        isValid: false,
        reason: `Public input length mismatch (expected ${vkResult.publicInputCount}, got ${publicInputs.length})`,
        verificationTimeMs,
        circuitType: input.circuitType,
        noirVersion: identity.noirVersion,
        circuitHash: identity.circuitHash,
        circuitId: identity.circuitId,
        verificationKeyHash: identity.verificationKeyHash,
        verificationKeyPoseidonHash: identity.verificationKeyPoseidonHash,
        bbVersion,
      };
    }

    let isValid: boolean;
    try {
      const verifier = await getVerifierBackend();
      isValid = await verifier.verifyProof({
        proof: new Uint8Array(proofBytes),
        publicInputs,
        verificationKey: Buffer.from(vkResult.verificationKey, "base64"),
      });
    } catch (error) {
      if (!isInvalidCrsError(error)) {
        throw error;
      }
      clearCrsCache("invalid CRS identity");
      const verifier = await getVerifierBackend();
      isValid = await verifier.verifyProof({
        proof: new Uint8Array(proofBytes),
        publicInputs,
        verificationKey: Buffer.from(vkResult.verificationKey, "base64"),
      });
    }

    const verificationTimeMs = performance.now() - start;
    recordZkVerifyDuration(verificationTimeMs, {
      circuit_type: input.circuitType,
      result: "ok",
    });

    return {
      isValid,
      verificationTimeMs,
      circuitType: input.circuitType,
      noirVersion: identity.noirVersion,
      circuitHash: identity.circuitHash,
      circuitId: identity.circuitId,
      verificationKeyHash: identity.verificationKeyHash,
      verificationKeyPoseidonHash: identity.verificationKeyPoseidonHash,
      bbVersion,
    };
  } catch (error) {
    recordZkVerifyDuration(performance.now() - start, {
      circuit_type: input.circuitType,
      result: "error",
    });
    throw new Error(
      `Proof verification failed: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
