/**
 * Server-Side Noir Proof Verification
 *
 * Verifies UltraHonk proofs generated by the browser using bb.js.
 *
 * NOTE: bb.js execution can be unstable under the Bun runtime, so server-side
 * verification is executed in a dedicated Node.js worker process.
 */

import "server-only";

import { type ChildProcessWithoutNullStreams, spawn } from "node:child_process";
import { createHash } from "node:crypto";
import * as fs from "node:fs";
import { createRequire } from "node:module";
import * as path from "node:path";
import { createInterface } from "node:readline";
import { fileURLToPath } from "node:url";
// Circuit artifacts (compiled from Noir)
import ageCircuit from "@/noir-circuits/age_verification/artifacts/age_verification.json";
import docValidityCircuit from "@/noir-circuits/doc_validity/artifacts/doc_validity.json";
import faceMatchCircuit from "@/noir-circuits/face_match/artifacts/face_match.json";
import nationalityCircuit from "@/noir-circuits/nationality_membership/artifacts/nationality_membership.json";
import type { CircuitType } from "./zk-circuit-spec";

export type { CircuitType } from "./zk-circuit-spec";

const CIRCUITS = {
  age_verification: ageCircuit,
  doc_validity: docValidityCircuit,
  nationality_membership: nationalityCircuit,
  face_match: faceMatchCircuit,
} as const;

export interface NoirVerifyInput {
  proof: string; // Base64 encoded Uint8Array
  publicInputs: string[];
  circuitType: CircuitType;
}

export interface NoirVerifyResult {
  isValid: boolean;
  verificationTimeMs: number;
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  circuitId: string | null;
  verificationKeyHash: string | null;
  bbVersion: string | null;
}

let cachedBbJsVersion: string | null | undefined;

export function getCircuitMetadata(circuitType: CircuitType): {
  noirVersion: string | null;
  circuitHash: string | null;
} {
  const circuit = CIRCUITS[circuitType] as unknown as {
    noir_version?: string;
    hash?: string | number;
  };

  return {
    noirVersion: circuit.noir_version ?? null,
    circuitHash:
      circuit.hash === undefined || circuit.hash === null
        ? null
        : String(circuit.hash),
  };
}

export function getBbJsVersion(): string | null {
  if (cachedBbJsVersion !== undefined) return cachedBbJsVersion;

  try {
    const require = createRequire(import.meta.url);
    const entryPath = require.resolve("@aztec/bb.js");

    // Walk up to find the nearest package.json (exports may block requiring it directly).
    let currentDir = path.dirname(entryPath);
    for (let i = 0; i < 10; i++) {
      const pkgPath = path.join(currentDir, "package.json");
      if (fs.existsSync(pkgPath)) {
        const raw = fs.readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(raw) as { version?: unknown };
        cachedBbJsVersion =
          typeof parsed.version === "string" ? parsed.version : null;
        return cachedBbJsVersion;
      }

      const parent = path.dirname(currentDir);
      if (parent === currentDir) break;
      currentDir = parent;
    }

    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  } catch {
    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  }
}

function normalizePublicInput(input: string): string {
  const trimmed = input.trim();
  if (!trimmed) return trimmed;
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) return trimmed;
  if (/^[0-9]+$/.test(trimmed)) return trimmed;
  if (/^[0-9a-fA-F]+$/.test(trimmed)) return `0x${trimmed}`;
  return trimmed;
}

type BbWorkerMethod = "getVerificationKey" | "verifyProof";

type BbWorkerSuccess<T> = {
  id: string;
  result: T;
};

type BbWorkerFailure = {
  id: string | null;
  error: {
    message: string;
  };
};

type BbWorkerResponse<T> = BbWorkerSuccess<T> | BbWorkerFailure;

let bbWorkerProcess: ChildProcessWithoutNullStreams | null = null;
let bbWorkerReadline: ReturnType<typeof createInterface> | null = null;
let bbWorkerNextId = 0;

const bbWorkerPending = new Map<
  string,
  {
    resolve: (value: unknown) => void;
    reject: (error: Error) => void;
  }
>();

const DEFAULT_BB_WORKER_PATH = fileURLToPath(
  new URL("./bb-worker.mjs", import.meta.url),
);

function getBbWorkerScriptPath(): string {
  return process.env.BB_WORKER_PATH || DEFAULT_BB_WORKER_PATH;
}

function getBbWorkerNodeBinary(): string {
  return process.env.BB_NODE_BINARY || "node";
}

function resetBbWorker(error: Error) {
  bbWorkerProcess = null;
  bbWorkerReadline?.close();
  bbWorkerReadline = null;

  for (const [id, pending] of bbWorkerPending) {
    pending.reject(
      new Error(
        `bb-worker exited before responding (id=${id}): ${error.message}`,
      ),
    );
  }
  bbWorkerPending.clear();
}

function ensureBbWorker(): ChildProcessWithoutNullStreams {
  if (bbWorkerProcess) return bbWorkerProcess;

  const nodeBinary = getBbWorkerNodeBinary();
  const workerPath = getBbWorkerScriptPath();

  const child = spawn(nodeBinary, [workerPath], {
    cwd: process.cwd(),
    env: process.env,
    stdio: ["pipe", "pipe", "pipe"],
  });

  child.on("error", (error) => {
    resetBbWorker(error instanceof Error ? error : new Error(String(error)));
  });

  child.on("exit", (code, signal) => {
    resetBbWorker(
      new Error(
        `bb-worker exited with code=${code ?? "null"} signal=${signal ?? "null"}`,
      ),
    );
  });

  child.stderr.on("data", (chunk) => {
    const text =
      chunk instanceof Buffer ? chunk.toString("utf8") : String(chunk);
    const trimmed = text.trim();
    if (trimmed) process.stderr.write(`[bb-worker] ${trimmed}\n`);
  });

  bbWorkerReadline = createInterface({
    input: child.stdout,
    crlfDelay: Infinity,
  });

  bbWorkerReadline.on("line", (line) => {
    if (!line.trim()) return;
    let parsed: BbWorkerResponse<unknown>;
    try {
      parsed = JSON.parse(line) as BbWorkerResponse<unknown>;
    } catch {
      return;
    }

    const id = typeof parsed.id === "string" ? parsed.id : null;
    if (!id) return;

    const pending = bbWorkerPending.get(id);
    if (!pending) return;
    bbWorkerPending.delete(id);

    if ("error" in parsed) {
      pending.reject(new Error(parsed.error?.message || "bb-worker error"));
      return;
    }

    pending.resolve(parsed.result);
  });

  bbWorkerProcess = child;
  return child;
}

async function callBbWorker<TResult>(
  method: BbWorkerMethod,
  params: unknown,
): Promise<TResult> {
  const worker = ensureBbWorker();
  const id = String(++bbWorkerNextId);

  const payload = `${JSON.stringify({ id, method, params })}\n`;

  return await new Promise<TResult>((resolve, reject) => {
    const rawTimeoutMs = Number.parseInt(
      process.env.BB_WORKER_TIMEOUT_MS || "",
      10,
    );
    const timeoutMs =
      Number.isFinite(rawTimeoutMs) && rawTimeoutMs > 0 ? rawTimeoutMs : 30_000;

    const timeoutId = setTimeout(() => {
      bbWorkerPending.delete(id);
      reject(
        new Error(
          `bb-worker request timed out after ${timeoutMs}ms (${method})`,
        ),
      );
    }, timeoutMs);

    bbWorkerPending.set(id, {
      resolve: (value) => {
        clearTimeout(timeoutId);
        resolve(value as TResult);
      },
      reject: (error) => {
        clearTimeout(timeoutId);
        reject(error);
      },
    });

    worker.stdin.write(payload, (error) => {
      if (!error) return;
      bbWorkerPending.delete(id);
      reject(error instanceof Error ? error : new Error(String(error)));
    });
  });
}

function getCircuitBytecode(circuitType: CircuitType): string {
  const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
  const bytecode = circuit?.bytecode;
  if (typeof bytecode !== "string" || !bytecode) {
    throw new Error(`Missing circuit bytecode for ${circuitType}`);
  }
  return bytecode;
}

const identityCache = new Map<CircuitType, Promise<CircuitIdentity>>();
const vkeyCache = new Map<
  CircuitType,
  Promise<{
    verificationKey: string;
    verificationKeyHash: string;
    size: number;
  }>
>();

export type CircuitIdentity = {
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  bbVersion: string | null;
  bytecodeHash: string | null;
  verificationKeyHash: string | null;
  circuitId: string | null;
};

function sha256Hex(input: Uint8Array | string): string {
  return createHash("sha256").update(input).digest("hex");
}

export async function getCircuitVerificationKey(
  circuitType: CircuitType,
): Promise<{
  verificationKey: string;
  verificationKeyHash: string;
  size: number;
}> {
  const existing = vkeyCache.get(circuitType);
  if (existing) return existing;

  const promise = callBbWorker<{
    verificationKey: string;
    verificationKeyHash: string;
    size: number;
  }>("getVerificationKey", {
    circuitType,
    bytecode: getCircuitBytecode(circuitType),
  });

  vkeyCache.set(circuitType, promise);
  return promise;
}

export async function getCircuitIdentity(
  circuitType: CircuitType,
): Promise<CircuitIdentity> {
  const existing = identityCache.get(circuitType);
  if (existing) return existing;

  const identityPromise = (async (): Promise<CircuitIdentity> => {
    const bbVersion = getBbJsVersion();
    const meta = getCircuitMetadata(circuitType);
    const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
    const bytecode =
      circuit && typeof circuit.bytecode === "string" ? circuit.bytecode : null;

    try {
      const vk = await getCircuitVerificationKey(circuitType);
      const verificationKeyHash = vk.verificationKeyHash;
      const bytecodeHash = bytecode ? sha256Hex(bytecode) : null;
      const circuitId = `ultrahonk:${verificationKeyHash}`;

      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash,
        verificationKeyHash,
        circuitId,
      };
    } catch {
      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash: bytecode ? sha256Hex(bytecode) : null,
        verificationKeyHash: null,
        circuitId: null,
      };
    }
  })();

  identityCache.set(circuitType, identityPromise);
  return identityPromise;
}

/**
 * Verify a ZK proof using UltraHonk backend
 *
 * @param input - Proof data including base64-encoded proof bytes and public inputs
 * @returns Verification result with timing information
 */
export async function verifyNoirProof(
  input: NoirVerifyInput,
): Promise<NoirVerifyResult> {
  const identity = await getCircuitIdentity(input.circuitType);
  const bbVersion = getBbJsVersion();

  try {
    const publicInputs = input.publicInputs.map(normalizePublicInput);

    const workerResult = await callBbWorker<{
      isValid: boolean;
      verificationTimeMs: number;
    }>("verifyProof", {
      circuitType: input.circuitType,
      bytecode: getCircuitBytecode(input.circuitType),
      proof: input.proof,
      publicInputs,
    });

    return {
      isValid: workerResult.isValid,
      verificationTimeMs: workerResult.verificationTimeMs,
      circuitType: input.circuitType,
      noirVersion: identity.noirVersion,
      circuitHash: identity.circuitHash,
      circuitId: identity.circuitId,
      verificationKeyHash: identity.verificationKeyHash,
      bbVersion,
    };
  } catch (error) {
    throw new Error(
      `Proof verification failed: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

/**
 * Get today's date as YYYYMMDD integer (for policy validation)
 */
export function getTodayAsInt(): number {
  const today = new Date();
  return (
    today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate()
  );
}
