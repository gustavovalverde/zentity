/**
 * Server-Side Noir Proof Verification
 *
 * Verifies UltraHonk proofs generated by the browser using bb.js.
 * bb.js works in both browser and Node.js environments.
 */

import { createHash } from "node:crypto";
import * as fs from "node:fs";
import { createRequire } from "node:module";
import * as path from "node:path";
// Circuit artifacts (compiled from Noir)
import ageCircuit from "@/noir-circuits/age_verification/artifacts/age_verification.json";
import docValidityCircuit from "@/noir-circuits/doc_validity/artifacts/doc_validity.json";
import faceMatchCircuit from "@/noir-circuits/face_match/artifacts/face_match.json";
import nationalityCircuit from "@/noir-circuits/nationality_membership/artifacts/nationality_membership.json";
import type { CircuitType } from "./zk-circuit-spec";

export type { CircuitType } from "./zk-circuit-spec";

const CIRCUITS = {
  age_verification: ageCircuit,
  doc_validity: docValidityCircuit,
  nationality_membership: nationalityCircuit,
  face_match: faceMatchCircuit,
} as const;

export interface NoirVerifyInput {
  proof: string; // Base64 encoded Uint8Array
  publicInputs: string[];
  circuitType: CircuitType;
}

export interface NoirVerifyResult {
  isValid: boolean;
  verificationTimeMs: number;
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  circuitId: string | null;
  verificationKeyHash: string | null;
  bbVersion: string | null;
}

let cachedBbJsVersion: string | null | undefined;

export function getCircuitMetadata(circuitType: CircuitType): {
  noirVersion: string | null;
  circuitHash: string | null;
} {
  const circuit = CIRCUITS[circuitType] as unknown as {
    noir_version?: string;
    hash?: string | number;
  };

  return {
    noirVersion: circuit.noir_version ?? null,
    circuitHash:
      circuit.hash === undefined || circuit.hash === null
        ? null
        : String(circuit.hash),
  };
}

export function getBbJsVersion(): string | null {
  if (cachedBbJsVersion !== undefined) return cachedBbJsVersion;

  try {
    const require = createRequire(import.meta.url);
    const entryPath = require.resolve("@aztec/bb.js");

    // Walk up to find the nearest package.json (exports may block requiring it directly).
    let currentDir = path.dirname(entryPath);
    for (let i = 0; i < 10; i++) {
      const pkgPath = path.join(currentDir, "package.json");
      if (fs.existsSync(pkgPath)) {
        const raw = fs.readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(raw) as { version?: unknown };
        cachedBbJsVersion =
          typeof parsed.version === "string" ? parsed.version : null;
        return cachedBbJsVersion;
      }

      const parent = path.dirname(currentDir);
      if (parent === currentDir) break;
      currentDir = parent;
    }

    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  } catch {
    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  }
}

function getBbCrsPath(): string | undefined {
  // In serverless Node runtimes, /tmp is the only writeable location.
  // Allow overriding via env for platforms with a different writable mount.
  return process.env.BB_CRS_PATH || "/tmp/.bb-crs";
}

function normalizePublicInput(input: string): string {
  const trimmed = input.trim();
  if (!trimmed) return trimmed;
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) return trimmed;
  if (/^[0-9]+$/.test(trimmed)) return trimmed;
  if (/^[0-9a-fA-F]+$/.test(trimmed)) return `0x${trimmed}`;
  return trimmed;
}

let cachedUltraHonkBackend:
  | typeof import("@aztec/bb.js").UltraHonkBackend
  | null
  | undefined;
const backendCache = new Map<
  CircuitType,
  import("@aztec/bb.js").UltraHonkBackend
>();
const identityCache = new Map<CircuitType, Promise<CircuitIdentity>>();
const vkeyCache = new Map<CircuitType, Promise<Uint8Array>>();

async function getBackend(
  circuitType: CircuitType,
): Promise<import("@aztec/bb.js").UltraHonkBackend> {
  const existing = backendCache.get(circuitType);
  if (existing) return existing;

  if (cachedUltraHonkBackend === undefined) {
    try {
      const bbModule = await import("@aztec/bb.js");
      cachedUltraHonkBackend = bbModule.UltraHonkBackend;
    } catch {
      cachedUltraHonkBackend = null;
    }
  }

  if (!cachedUltraHonkBackend) {
    throw new Error(
      "Failed to load bb.js for verification. Ensure @aztec/bb.js is installed and properly configured in next.config.ts.",
    );
  }

  const circuit = CIRCUITS[circuitType];
  if (!circuit) throw new Error(`Unknown circuit type: ${circuitType}`);

  const backend = new cachedUltraHonkBackend(
    (circuit as { bytecode: string }).bytecode,
    { crsPath: getBbCrsPath() },
  );
  backendCache.set(circuitType, backend);
  return backend;
}

export type CircuitIdentity = {
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  bbVersion: string | null;
  bytecodeHash: string | null;
  verificationKeyHash: string | null;
  circuitId: string | null;
};

function sha256Hex(input: Uint8Array | string): string {
  return createHash("sha256").update(input).digest("hex");
}

function coerceUint8Array(value: unknown): Uint8Array {
  if (value instanceof Uint8Array) return value;
  if (value && typeof value === "object" && "key" in value) {
    const key = (value as { key?: unknown }).key;
    if (key instanceof Uint8Array) return key;
  }
  if (value && typeof value === "object" && "buffer" in value) {
    const buffer = (value as { buffer?: unknown }).buffer;
    if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);
  }
  return new Uint8Array(value as ArrayBufferLike);
}

async function getCircuitVerificationKeyBytes(
  circuitType: CircuitType,
): Promise<Uint8Array> {
  const existing = vkeyCache.get(circuitType);
  if (existing) return existing;

  const promise = (async () => {
    const backend = await getBackend(circuitType);
    return coerceUint8Array(await backend.getVerificationKey());
  })();
  vkeyCache.set(circuitType, promise);
  return promise;
}

export async function getCircuitVerificationKey(
  circuitType: CircuitType,
): Promise<{
  verificationKey: string;
  verificationKeyHash: string;
  size: number;
}> {
  const bytes = await getCircuitVerificationKeyBytes(circuitType);
  return {
    verificationKey: Buffer.from(bytes).toString("base64"),
    verificationKeyHash: sha256Hex(bytes),
    size: bytes.length,
  };
}

export async function getCircuitIdentity(
  circuitType: CircuitType,
): Promise<CircuitIdentity> {
  const existing = identityCache.get(circuitType);
  if (existing) return existing;

  const identityPromise = (async (): Promise<CircuitIdentity> => {
    const bbVersion = getBbJsVersion();
    const meta = getCircuitMetadata(circuitType);
    const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
    const bytecode =
      circuit && typeof circuit.bytecode === "string" ? circuit.bytecode : null;

    try {
      const vkBytes = await getCircuitVerificationKeyBytes(circuitType);
      const verificationKeyHash = sha256Hex(vkBytes);
      const bytecodeHash = bytecode ? sha256Hex(bytecode) : null;
      const circuitId = `ultrahonk:${verificationKeyHash}`;

      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash,
        verificationKeyHash,
        circuitId,
      };
    } catch {
      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash: bytecode ? sha256Hex(bytecode) : null,
        verificationKeyHash: null,
        circuitId: null,
      };
    }
  })();

  identityCache.set(circuitType, identityPromise);
  return identityPromise;
}

/**
 * Verify a ZK proof using UltraHonk backend
 *
 * @param input - Proof data including base64-encoded proof bytes and public inputs
 * @returns Verification result with timing information
 */
export async function verifyNoirProof(
  input: NoirVerifyInput,
): Promise<NoirVerifyResult> {
  const startTime = Date.now();
  const identity = await getCircuitIdentity(input.circuitType);
  const bbVersion = getBbJsVersion();

  try {
    const backend = await getBackend(input.circuitType);

    // Decode base64 proof to Uint8Array
    const proofBytes = Buffer.from(input.proof, "base64");
    const publicInputs = input.publicInputs.map(normalizePublicInput);

    const isValid = await backend.verifyProof({
      proof: new Uint8Array(proofBytes),
      publicInputs,
    });

    return {
      isValid,
      verificationTimeMs: Date.now() - startTime,
      circuitType: input.circuitType,
      noirVersion: identity.noirVersion,
      circuitHash: identity.circuitHash,
      circuitId: identity.circuitId,
      verificationKeyHash: identity.verificationKeyHash,
      bbVersion,
    };
  } catch (error) {
    throw new Error(
      `Proof verification failed: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

/**
 * Get today's date as YYYYMMDD integer (for policy validation)
 */
export function getTodayAsInt(): number {
  const today = new Date();
  return (
    today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate()
  );
}
