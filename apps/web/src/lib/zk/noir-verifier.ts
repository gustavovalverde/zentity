/**
 * Server-Side Noir Proof Verification
 *
 * Verifies UltraHonk proofs generated by the browser using bb.js.
 * Server-side verification is executed in a dedicated Node.js worker process
 * for stability and isolation.
 */

import "server-only";

import type { CircuitType } from "./zk-circuit-spec";

import { type ChildProcessWithoutNullStreams, spawn } from "node:child_process";
import { createHash } from "node:crypto";
import { existsSync, readFileSync } from "node:fs";
import { createRequire } from "node:module";
import { cpus } from "node:os";
import { dirname, join, resolve } from "node:path";
import { createInterface } from "node:readline";
import { fileURLToPath } from "node:url";

import { logger } from "@/lib/logging/logger";
import { recordZkVerifyDuration } from "@/lib/observability/metrics";
// Circuit artifacts (compiled from Noir)
import ageCircuit from "@/noir-circuits/age_verification/artifacts/age_verification.json";
import docValidityCircuit from "@/noir-circuits/doc_validity/artifacts/doc_validity.json";
import faceMatchCircuit from "@/noir-circuits/face_match/artifacts/face_match.json";
import nationalityCircuit from "@/noir-circuits/nationality_membership/artifacts/nationality_membership.json";

const CIRCUITS = {
  age_verification: ageCircuit,
  doc_validity: docValidityCircuit,
  nationality_membership: nationalityCircuit,
  face_match: faceMatchCircuit,
} as const;

/** Matches one or more digits (for decimal number validation) */
const DECIMAL_NUMBER_PATTERN = /^\d+$/;
/** Matches hexadecimal characters (0-9, a-f, A-F) */
const HEX_CHARS_PATTERN = /^[0-9a-fA-F]+$/;

interface NoirVerifyInput {
  proof: string; // Base64 encoded Uint8Array
  publicInputs: string[];
  circuitType: CircuitType;
}

interface NoirVerifyResult {
  isValid: boolean;
  reason?: string;
  verificationTimeMs: number;
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  circuitId: string | null;
  verificationKeyHash: string | null;
  verificationKeyPoseidonHash: string | null;
  bbVersion: string | null;
}

let cachedBbJsVersion: string | null | undefined;
let prewarmPromise: Promise<void> | null = null;

export function getCircuitMetadata(circuitType: CircuitType): {
  noirVersion: string | null;
  circuitHash: string | null;
} {
  const circuit = CIRCUITS[circuitType] as unknown as {
    noir_version?: string;
    hash?: string | number;
  };

  return {
    noirVersion: circuit.noir_version ?? null,
    circuitHash:
      circuit.hash === undefined || circuit.hash === null
        ? null
        : String(circuit.hash),
  };
}

export function getBbJsVersion(): string | null {
  if (cachedBbJsVersion !== undefined) {
    return cachedBbJsVersion;
  }

  try {
    const require = createRequire(import.meta.url);
    const entryPath = require.resolve("@aztec/bb.js");

    // Walk up to find the nearest package.json (exports may block requiring it directly).
    let currentDir = dirname(entryPath);
    for (let i = 0; i < 10; i++) {
      const pkgPath = join(currentDir, "package.json");
      if (existsSync(pkgPath)) {
        const raw = readFileSync(pkgPath, "utf8");
        const parsed = JSON.parse(raw) as { version?: unknown };
        cachedBbJsVersion =
          typeof parsed.version === "string" ? parsed.version : null;
        return cachedBbJsVersion;
      }

      const parent = dirname(currentDir);
      if (parent === currentDir) {
        break;
      }
      currentDir = parent;
    }

    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  } catch {
    cachedBbJsVersion = null;
    return cachedBbJsVersion;
  }
}

function normalizePublicInput(input: string): string {
  const trimmed = input.trim();
  if (!trimmed) {
    return trimmed;
  }
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
    return trimmed;
  }
  if (DECIMAL_NUMBER_PATTERN.test(trimmed)) {
    return trimmed;
  }
  if (HEX_CHARS_PATTERN.test(trimmed)) {
    return `0x${trimmed}`;
  }
  return trimmed;
}

type BbWorkerMethod = "getVerificationKey" | "verifyProof";

interface BbWorkerSuccess<T> {
  id: string;
  result: T;
}

interface BbWorkerFailure {
  id: string | null;
  error: {
    message: string;
  };
}

type BbWorkerResponse<T> = BbWorkerSuccess<T> | BbWorkerFailure;

interface BbWorkerState {
  index: number;
  process: ChildProcessWithoutNullStreams;
  readline: ReturnType<typeof createInterface>;
  pending: Map<
    string,
    {
      resolve: (value: unknown) => void;
      reject: (error: Error) => void;
    }
  >;
  nextId: number;
  inflight: number;
}

const bbWorkerPool: Array<BbWorkerState | null> = [];
let bbWorkerPoolSize: number | null = null;

const DEFAULT_BB_WORKER_PATH = (() => {
  try {
    return fileURLToPath(new URL("./bb-worker.mjs", import.meta.url));
  } catch {
    return resolve(process.cwd(), "src/lib/zk/bb-worker.mjs");
  }
})();

function getBbWorkerScriptPath(): string {
  return process.env.BB_WORKER_PATH || DEFAULT_BB_WORKER_PATH;
}

function getBbWorkerNodeBinary(): string {
  return process.env.BB_NODE_BINARY || "node";
}

function resetBbWorker(index: number, error: Error) {
  const worker = bbWorkerPool[index];
  if (!worker) {
    return;
  }
  worker.readline.close();
  for (const [id, pending] of worker.pending) {
    pending.reject(
      new Error(
        `bb-worker exited before responding (id=${id}): ${error.message}`
      )
    );
  }
  worker.pending.clear();
  bbWorkerPool[index] = null;
}

function getBbWorkerPoolSize(): number {
  const parsed = Number.parseInt(process.env.BB_WORKER_POOL_SIZE || "", 10);
  if (Number.isFinite(parsed) && parsed > 0) {
    return parsed;
  }
  const cpuCount = Math.max(1, cpus()?.length ?? 1);
  return Math.max(1, Math.min(4, cpuCount));
}

function spawnBbWorker(index: number): BbWorkerState {
  const nodeBinary = getBbWorkerNodeBinary();
  const workerPath = getBbWorkerScriptPath();

  const child = spawn(nodeBinary, [workerPath], {
    cwd: process.cwd(),
    env: process.env,
    stdio: ["pipe", "pipe", "pipe"],
  });

  const worker: BbWorkerState = {
    index,
    process: child,
    readline: createInterface({
      input: child.stdout,
      crlfDelay: Number.POSITIVE_INFINITY,
    }),
    pending: new Map(),
    nextId: 0,
    inflight: 0,
  };

  child.on("error", (error) => {
    resetBbWorker(
      index,
      error instanceof Error ? error : new Error(String(error))
    );
  });

  child.on("exit", (code, signal) => {
    resetBbWorker(
      index,
      new Error(
        `bb-worker exited with code=${code ?? "null"} signal=${signal ?? "null"}`
      )
    );
  });

  child.stderr.on("data", (chunk) => {
    const text =
      chunk instanceof Buffer ? chunk.toString("utf8") : String(chunk);
    const trimmed = text.trim();
    if (trimmed) {
      process.stderr.write(`[bb-worker:${index}] ${trimmed}\n`);
    }
  });

  worker.readline.on("line", (line) => {
    if (!line.trim()) {
      return;
    }
    let parsed: BbWorkerResponse<unknown>;
    try {
      parsed = JSON.parse(line) as BbWorkerResponse<unknown>;
    } catch {
      return;
    }

    const id = typeof parsed.id === "string" ? parsed.id : null;
    if (!id) {
      return;
    }

    const pending = worker.pending.get(id);
    if (!pending) {
      return;
    }
    worker.pending.delete(id);

    if ("error" in parsed) {
      pending.reject(new Error(parsed.error?.message || "bb-worker error"));
      return;
    }

    pending.resolve(parsed.result);
  });

  return worker;
}

function ensureBbWorkerPool(): BbWorkerState[] {
  if (!bbWorkerPoolSize) {
    bbWorkerPoolSize = getBbWorkerPoolSize();
  }
  while (bbWorkerPool.length < bbWorkerPoolSize) {
    bbWorkerPool.push(null);
  }
  for (let i = 0; i < bbWorkerPoolSize; i += 1) {
    bbWorkerPool[i] ??= spawnBbWorker(i);
  }
  return bbWorkerPool.filter(Boolean) as BbWorkerState[];
}

function pickBbWorker(pool: BbWorkerState[]): BbWorkerState {
  if (pool.length === 0) {
    throw new Error("No bb-worker processes available");
  }
  let selected = pool[0];
  for (const worker of pool) {
    if (worker.inflight < selected.inflight) {
      selected = worker;
    }
  }
  return selected;
}

async function callBbWorker<TResult>(
  method: BbWorkerMethod,
  params: unknown
): Promise<TResult> {
  const pool = ensureBbWorkerPool();
  const worker = pickBbWorker(pool);
  const id = `${worker.index}-${++worker.nextId}`;

  const payload = `${JSON.stringify({ id, method, params })}\n`;

  return await new Promise<TResult>((promiseResolve, promiseReject) => {
    const rawTimeoutMs = Number.parseInt(
      process.env.BB_WORKER_TIMEOUT_MS || "",
      10
    );
    const timeoutMs =
      Number.isFinite(rawTimeoutMs) && rawTimeoutMs > 0 ? rawTimeoutMs : 30_000;

    const timeoutId = setTimeout(() => {
      worker.pending.delete(id);
      worker.inflight = Math.max(0, worker.inflight - 1);
      promiseReject(
        new Error(
          `bb-worker request timed out after ${timeoutMs}ms (${method})`
        )
      );
    }, timeoutMs);

    worker.pending.set(id, {
      resolve: (value) => {
        clearTimeout(timeoutId);
        worker.inflight = Math.max(0, worker.inflight - 1);
        promiseResolve(value as TResult);
      },
      reject: (error) => {
        clearTimeout(timeoutId);
        worker.inflight = Math.max(0, worker.inflight - 1);
        promiseReject(error);
      },
    });
    worker.inflight += 1;

    worker.process.stdin.write(payload, (error) => {
      if (!error) {
        return;
      }
      worker.pending.delete(id);
      worker.inflight = Math.max(0, worker.inflight - 1);
      promiseReject(error instanceof Error ? error : new Error(String(error)));
    });
  });
}

function getCircuitBytecode(circuitType: CircuitType): string {
  const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
  const bytecode = circuit?.bytecode;
  if (typeof bytecode !== "string" || !bytecode) {
    throw new Error(`Missing circuit bytecode for ${circuitType}`);
  }
  return bytecode;
}

const identityCache = new Map<CircuitType, Promise<CircuitIdentity>>();
const vkeyCache = new Map<
  CircuitType,
  Promise<{
    verificationKey: string;
    verificationKeyHash: string;
    verificationKeyPoseidonHash: string;
    publicInputCount: number;
    size: number;
  }>
>();

interface CircuitIdentity {
  circuitType: CircuitType;
  noirVersion: string | null;
  circuitHash: string | null;
  bbVersion: string | null;
  bytecodeHash: string | null;
  verificationKeyHash: string | null;
  verificationKeyPoseidonHash: string | null;
  publicInputCount: number | null;
  circuitId: string | null;
}

function sha256Hex(input: Uint8Array | string): string {
  return createHash("sha256").update(input).digest("hex");
}

export function getCircuitVerificationKey(circuitType: CircuitType): Promise<{
  verificationKey: string;
  verificationKeyHash: string;
  verificationKeyPoseidonHash: string;
  publicInputCount: number;
  size: number;
}> {
  const existing = vkeyCache.get(circuitType);
  if (existing) {
    return existing;
  }

  const promise = callBbWorker<{
    verificationKey: string;
    verificationKeyHash: string;
    verificationKeyPoseidonHash: string;
    publicInputCount: number;
    size: number;
  }>("getVerificationKey", {
    circuitType,
    bytecode: getCircuitBytecode(circuitType),
  });

  vkeyCache.set(circuitType, promise);
  return promise;
}

export function prewarmVerificationKeys(): Promise<void> {
  if (prewarmPromise) {
    return prewarmPromise;
  }

  prewarmPromise = (async () => {
    const circuitTypes = Object.keys(CIRCUITS) as CircuitType[];
    const failures: unknown[] = [];
    for (const circuitType of circuitTypes) {
      try {
        await getCircuitVerificationKey(circuitType);
      } catch (error) {
        failures.push(error);
      }
    }

    if (failures.length) {
      const message = failures
        .map((failure) =>
          failure instanceof Error ? failure.message : String(failure)
        )
        .filter(Boolean)
        .join(", ");
      throw new Error(
        message
          ? `Failed to prewarm verification keys: ${message}`
          : "Failed to prewarm verification keys"
      );
    }
  })();

  return prewarmPromise;
}

/**
 * Warm up CRS cache and verification keys on server startup.
 * Called from instrumentation.ts to eliminate cold start latency.
 */
export async function warmupCRS(): Promise<void> {
  const startTime = Date.now();
  try {
    await prewarmVerificationKeys();
    logger.info(
      { durationMs: Date.now() - startTime, circuits: Object.keys(CIRCUITS) },
      "ZK verification keys preloaded (CRS cached)"
    );
  } catch (error) {
    logger.warn(
      {
        err: error,
        durationMs: Date.now() - startTime,
        circuits: Object.keys(CIRCUITS),
      },
      "ZK verification key warmup failed"
    );
    if (process.env.ZK_WARMUP_STRICT === "true") {
      throw error;
    }
  }
}

export function getCircuitIdentity(
  circuitType: CircuitType
): Promise<CircuitIdentity> {
  const existing = identityCache.get(circuitType);
  if (existing) {
    return existing;
  }

  const identityPromise = (async (): Promise<CircuitIdentity> => {
    const bbVersion = getBbJsVersion();
    const meta = getCircuitMetadata(circuitType);
    const circuit = CIRCUITS[circuitType] as { bytecode?: unknown } | undefined;
    const bytecode =
      circuit && typeof circuit.bytecode === "string" ? circuit.bytecode : null;

    try {
      const vk = await getCircuitVerificationKey(circuitType);
      const verificationKeyHash = vk.verificationKeyHash;
      const verificationKeyPoseidonHash = vk.verificationKeyPoseidonHash;
      const publicInputCount = vk.publicInputCount;
      const bytecodeHash = bytecode ? sha256Hex(bytecode) : null;
      const circuitId = `ultrahonk:${verificationKeyHash}`;

      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash,
        verificationKeyHash,
        verificationKeyPoseidonHash,
        publicInputCount,
        circuitId,
      };
    } catch {
      return {
        circuitType,
        noirVersion: meta.noirVersion,
        circuitHash: meta.circuitHash,
        bbVersion,
        bytecodeHash: bytecode ? sha256Hex(bytecode) : null,
        verificationKeyHash: null,
        verificationKeyPoseidonHash: null,
        publicInputCount: null,
        circuitId: null,
      };
    }
  })();

  identityCache.set(circuitType, identityPromise);
  return identityPromise;
}

/**
 * Verify a ZK proof using UltraHonk backend
 *
 * @param input - Proof data including base64-encoded proof bytes and public inputs
 * @returns Verification result with timing information
 */
export async function verifyNoirProof(
  input: NoirVerifyInput
): Promise<NoirVerifyResult> {
  const start = performance.now();
  const identity = await getCircuitIdentity(input.circuitType);
  const bbVersion = getBbJsVersion();

  try {
    const publicInputs = input.publicInputs.map(normalizePublicInput);

    const workerResult = await callBbWorker<{
      isValid: boolean;
      verificationTimeMs: number;
      reason?: string;
    }>("verifyProof", {
      circuitType: input.circuitType,
      bytecode: getCircuitBytecode(input.circuitType),
      proof: input.proof,
      publicInputs,
    });

    recordZkVerifyDuration(workerResult.verificationTimeMs, {
      circuit_type: input.circuitType,
      result: "ok",
    });

    return {
      isValid: workerResult.isValid,
      reason: workerResult.reason,
      verificationTimeMs: workerResult.verificationTimeMs,
      circuitType: input.circuitType,
      noirVersion: identity.noirVersion,
      circuitHash: identity.circuitHash,
      circuitId: identity.circuitId,
      verificationKeyHash: identity.verificationKeyHash,
      verificationKeyPoseidonHash: identity.verificationKeyPoseidonHash,
      bbVersion,
    };
  } catch (error) {
    recordZkVerifyDuration(performance.now() - start, {
      circuit_type: input.circuitType,
      result: "error",
    });
    throw new Error(
      `Proof verification failed: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}

/**
 * Get today's date as YYYYMMDD integer (for policy validation)
 */
function _getTodayAsInt(): number {
  const today = new Date();
  return (
    today.getFullYear() * 10_000 +
    (today.getMonth() + 1) * 100 +
    today.getDate()
  );
}
